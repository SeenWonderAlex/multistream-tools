<html>

<head>
    <title>Multistream Tools - Polling (Beta)</title>
    <link rel="stylesheet" href="./style.css" />
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <style>
        #log {
            box-sizing: border-box;
            padding: 5px;
            width: 100%;
            height: 300px;
            overflow: auto;
            border: 1px solid #FFFFFF;
            border-radius: 20px;

            margin-bottom: 20px;
        }

        #log span {
            margin-right: 5px;
        }

        #subscriptions_refresh {
            cursor: pointer;
        }

        table {
            width: 100%;
        }
    </style>

    <style rel="stylesheet">
        #goals {
            /*position: absolute;*/
            bottom: 0px;
            left: 0px;
            right: 0px;
            background: darkred;
            color: palegoldenrod;
        }

        .goal {
            height: 50px;
            margin: 5px;
            background: red;
        }

        .goal_outer {
            position: relative;
            width: 100%;
            background: white;
            height: 50px;
        }

        .goal_inner {
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            background: yellow;
        }

        .goal_text_section {
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            line-height: 50px;
            font-size: 40px;
            color: #000000;
            text-align: center;
            background: transparent;
        }

        .goal_text_section span {
            margin: 0px 5px;
            color: #000000;
            background: transparent;
        }
    </style>
</head>

<body>
    <ul id="AuthRequired" style="display: none;">
        <img src="./cdn/HmmNotes-On_a_stack-7tv.gif">
        <span>This is Step 1. You'll first need to authenticate with Twitch. Click the button to prompt permissions.
            Right click if you only want to prompt the permissions we need.</span>
        <button id="authorize">Authorize Twitch</button>
    </ul>

    <details id="YouTubeConnection" open>
        <summary>Connect with YouTube</summary>
        <span>Load a recent stream or type your YouTube Stream URL in order to connect with YouTube.</span>
        <br>
        <input id="YouTubeURL" class="YU1" type="url">
        <button onclick="LoadURL();" class="YU2">Load</button>
        <button onclick="YoutubeLinkHandler();" id="YUHandler" class="YU2 YU3">Load from Recent</button>
    </details>

    <iframe id="TwitchChatDummyDoc" src="about:blank" height="450"
        sandbox="allow-storage-access-by-user-activation allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-modals"></iframe>
    <iframe id="YTChatDummyDoc" src="about:blank" height="450"></iframe>

    <div id="CurrentPoll" style="display: none;">
        <span class="PollQuestion PollQ">Poll Question</span>
        <p id="PollOption1" class="PollOption">0%</p>
        <div class="PollProgress">
            <div id="PPollOption1" class="PollProgressBar"></div>
        </div>
        <p id="PollOption2" class="PollOption">0%</p>
        <div class="PollProgress">
            <div id="PPollOption2" class="PollProgressBar"></div>
        </div>
        <p id="PollOption3" class="PollOption" style="display: none;">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="PPollOption3" class="PollProgressBar"></div>
        </div>
        <p id="PollOption4" class="PollOption" style="display: none;">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="PPollOption4" class="PollProgressBar"></div>
        </div>
        <p id="PollOption5" class="PollOption" style="display: none;">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="PPollOption5" class="PollProgressBar"></div>
        </div>
        <br>
        <br>
        <div class="PollProgress">
            <div id="PPollDuration" class="PollProgressBar RedColor"></div>
        </div>
        <p id="PollDuration">00:00</p>
        <button class="SubmitPoll" onclick="EndPollEarly(false)" oncontextmenu="event.preventDefault(); EndPollEarly(true);">End Polls Early</button>
    </div>

    <div id="PleaseWait" style="display: none;">
        <span class="PleaseWait">Checking for active polls</span>
    </div>

    <div id="PollWarning" style="display: none;">
        <span class="PollWarningText">You currently have an active poll. Do you want to continue creating a
            multistreaming Poll & end other poll(s)?</span>
        <br>
        <button class="SubmitPoll" onclick="EndPollEarly(false)">Continue & End Poll(s)</button>
    </div>

    <div id="CreatePollEditor" style="display: none;">
        <div id="Create">
            <p style="color: white; text-align: center;">CREATE A POLL FROM</p>
            <br>
            <button onclick="ShowPresets()" class="YU3" style="width: 49%;">Presets</button>
            <button onclick="ShowNewPoll()" style="width: 49%;" tabindex="1">New</button>
        </div>
        <div id="GetPresets" style="display: none;">
            <label for="EditorPresets">Select a Preset:</label>
            <select name="EditorPresets" id="EditorPresets" required>

            </select>
            <br>
            <div style="display: flex;">
                <button type="button" class="YU3" onclick="LoadPreset()">Load Preset</button>
                <button type="button" style="width: 25px; float: left; height: 25px; background: none;"
                    onclick="DeletePreset()">X</button>
            </div>

        </div>
        <div id="NewEditor" style="display: none;">
            <form action="#" onsubmit="event.preventDefault(); CheckPoll();">
                <span>Add up to 5 options on both platforms! Click the Create Poll button below to start a poll
                    in
                    both chats!</span>
                <br>
                <div style="display: flex;">
                    <input type="text" id="Editor_PollQuestion" class="YU1" placeholder="Ask a question..."
                        style="width: 100%;" required>
                    <button type="button" style="width: 25px; float: left; height: 25px;"
                        onclick="AddOption()">+</button>
                </div>
                <span>Choices:</span>
                <br>
                <div id="EditorOptions">
                    <div style="display: flex;">
                        <button type="button"
                            style="width: 25px; float: left; height: 25px; background: none;">X</button>
                        <input type="text" class="YU1" placeholder="Choice 1" required style="width: 100%;">
                    </div>
                    <div style="display: flex;">
                        <button type="button"
                            style="width: 25px; float: left; height: 25px; background: none;">X</button>
                        <input type="text" class="YU1" placeholder="Choice 2" required style="width: 100%;">
                    </div>
                </div>
                <label for="Editor_PollDuration">Poll Duration:</label>
                <select name="Editor_PollDuration" id="Editor_PollDuration">
                    <option value="30">30 Seconds</option>
                    <option value="60">1 Minute</option>
                    <option value="120">2 Minutes</option>
                    <option value="300">5 Minutes</option>
                    <option value="900">15 Minutes</option>
                    <option value="1800">30 Minutes</option>
                </select>
                <br>
                <button type="submit">Create Poll</button>
                <br>
                <button type="button" class="YU3" id="CreatePresetButton">Create Preset</button>
            </form>
        </div>
    </div>

    <details id="PollResultsDiv" open style="display: none;">
        <summary>Poll Results</summary>
        <span class="PollQuestion" id="Res_PollQuestion">Poll Question</span>
        <span class="PollQuestionInfo" id="Res_PollQuestionInfo"> (0 Votes)</span>
        <p id="Res_PollOption1" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt1_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt1_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
        <p id="Res_PollOption2" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt2_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt2_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
        <p id="Res_PollOption3" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt3_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt3_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
        <p id="Res_PollOption4" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt4_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt4_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
        <p id="Res_PollOption5" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt5_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt5_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
    </details>

    <!-- <details id="SpamProtectionDetailed" style="display: none;" open>
        <summary>Mod Settings</summary>
        <label class="switch">
            <input type="checkbox" checked id="ModSpamProtection">
            <span class="slider round"></span>
        </label>
        <br>
        <span>Killa Spam Protection</span>
    </details> -->

    <script type="text/javascript" src="./eventsub.js"></script>
    <script type="text/javascript">
        // These are set for the GitHub Pages Example
        // Substitute as needed
        var client_id = 'siayiyd16jh90e3j473ckuu2seoq0p';
        var redirect = (() => { let str = window.location.href; if (str.includes('?')) { str = str.split('?')[0]; } if (str.includes('#')) { str = str.split('#')[0]; } return str; })();
        var access_token = '';
        var socket_space = '';
        var session_id = '';
        var user_id = '';

        var ConnectedPollID = '';
        var ConnectedYTPoll = '';

        // Ellipsis Check
        var Ellipsis = 0;
        var redemptions = [];
        const EllipsisText = ["", ".", "..", "..."]

        var Presets = {};
        var Presets_Loaded = "";

        // document.getElementById('authorize').setAttribute('href', 'https://id.twitch.tv/oauth2/authorize?client_id=' + client_id + '&redirect_uri=' + encodeURIComponent(redirect) + '&response_type=token&scope=user:read:chat+channel:moderate+moderator:manage:banned_users+channel:manage:moderators+moderation:read+channel:read:redemptions+channel:manage:polls+channel:read:polls+moderator:read:chat_settings');
        document.getElementById('authorize').onclick = (ev) => { location.href = 'https://id.twitch.tv/oauth2/authorize?client_id=' + client_id + '&redirect_uri=' + encodeURIComponent(redirect) + '&response_type=token&scope=chat:read+channel:moderate+moderation:read+channel:read:redemptions+channel:manage:polls+channel:read:polls+moderator:read:chat_settings&state=ttv3e43v1' };
        document.getElementById('authorize').oncontextmenu = (ev) => { ev.preventDefault(); location.href = 'https://id.twitch.tv/oauth2/authorize?client_id=' + client_id + '&redirect_uri=' + encodeURIComponent(redirect) + '&response_type=token&scope=chat:read+channel:manage:polls+channel:read:polls&state=ttv3e43v1&force_verify=true' };
        document.addEventListener('DOMContentLoaded', () => {
            handleSavedToken();
        });
        function handleSavedToken() {
            const urlParams = new URLSearchParams(window.location.hash.replace('#', '?'));
            const myParam = urlParams.get('access_token');
            const isTwitch = urlParams.get('state') == "ttv3e43v1";
            const isYouTube = urlParams.get('state') == "yt35hv1";
            if (myParam != null && isTwitch) {
                processToken(myParam);
            }
            else if (localStorage.getItem('saved_access_token') != null) {
                processToken(localStorage.getItem('saved_access_token'));
            }
            else {
                const queryParams = new URLSearchParams(window.location.search);
                const error = queryParams.get('error');
                if (error != null) {
                    b("AuthRequired").className = "Oops";
                    b("AuthRequired").getElementsByTagName('img')[0].src = './cdn/Weirdge-perry8782-7tv.gif';
                    let Text = "We could not complete the authentication of your Twitch account: " + queryParams.get('error_description');
                    if (error == "access_denied") {
                        Text = "Don't like the permissions we have? No worries. Contact SeenWonderAlex and he'll give you permissions you need.";
                    }
                    else if (error == "redirect_mismatch") {
                        Text = "Are you in the right page? We are unable to complete this process. Feel free to try again or reopen this page from the source.";
                    }
                    b("AuthRequired").getElementsByTagName('span')[0].innerText = Text;
                    b("authorize").innerText = "Reauthorize Twitch";
                }
                document.getElementById("AuthRequired").style = '';
            }

            if (myParam != null && isYouTube) {
                verifyYTToken(myParam);
            }
            else if (localStorage.getItem('ytsavedtoken') != null) {
                verifyYTToken(localStorage.getItem('ytsavedtoken'));
            }
            else {
                b('YouTubeConnection').innerHTML = "YouTube Authentication is required to continue.";
                if (access_token.length > 0) {
                    b("AuthRequired").getElementsByTagName('span')[0].innerText = "Success! Now, you'll to authenticate your YouTube account. Please remember we are only using the Google API for this tool, and we will NOT use it for any other purpose. Since there is no specific permission, we have to ask this following scope which is the least we can do (PLEASE REMEMBER THAT WE ONLY USE THIS TO CREATE POLLS/GET RECENT BROADCASTS):";
                    b("AuthRequired").getElementsByTagName('span')[0].style.fontSize = "16px";
                    b("AuthRequired").className = "Oops";
                    let bullet = document.createElement('ul');
                    bullet.classList = "a";
                    bullet.innerText = "- See, edit, and permanently delete your YouTube videos, ratings, comments and captions";
                    b("AuthRequired").insertBefore(bullet, document.getElementById('authorize'));
                    b("AuthRequired").style.display = "";
                    document.getElementById('authorize').innerText = "Authorize YouTube (I acknowledge what I read above)"
                    document.getElementById('authorize').onclick = (ev) => { if (confirm("We will ask the permission that we specified. It'll be only used to function this tool. IT WILL NOT BE USED FOR ANY OTHER PURPOSE. In addition, token resets every hour so we'll need to ask you again if you want to continue using this tool. Continue?")) YoutubeLinkHandler(); };
                    document.body.insertBefore(b('AuthRequired').cloneNode(true), document.body.firstChild);
                    b("AuthRequired").style.display = "none";
                }
            }
        }

        function ShowPresets() {
            b('Create').style = "display: none;";
            b('NewEditor').style = "display: none;";
            LoadPresets();
            b('GetPresets').style = "";
        }

        function ShowNewPoll() {
            b('Create').style = "display: none;";
            b('NewEditor').style = "";
            b('GetPresets').style = "display: none;";
        }

        function AddOption() {
            const Options = b('EditorOptions');
            const option = document.createElement('div');
            const button = document.createElement('button');
            const input = document.createElement('input');
            option.style.display = "flex";
            button.style = "width: 25px; float: left; height: 25px; background: none;";
            button.innerText = "X";
            button.type = "button";
            button.tabIndex = 1;
            input.type = "text";
            input.className = "YU1";
            input.placeholder = "Choice " + (Options.childElementCount + 1);
            input.style.width = "100%";
            option.append(button);
            option.append(input);
            button.addEventListener('click', () => {
                if (b('EditorOptions').childElementCount <= 2) return; // Can't remove less than 2 options.
                option.remove();
                ValidatePollOptions();
                const OptionsList = b('EditorOptions').children;
                try {
                    for (let i = 0; i < OptionsList.length; i++) {
                        if (i <= 1) {
                            OptionsList[i].querySelector("div > input").required = true;
                        }
                        OptionsList[i].querySelector("div > input").placeholder = "Choice " + (i + 1);
                    }
                } catch (error) {
                    console.error(error);
                }
            });
            Options.append(option);
            ValidatePollOptions();
            return input;
        }

        // Check availability...
        function ValidatePollOptions() {
            const count = b('EditorOptions').childElementCount;
            b('NewEditor').querySelector("button[type=submit]").disabled = count < 2 || count > 5;
            return count >= 2 && count <= 5;
        }

        // Save Presets to local storage
        function SaveToLocalStorage() {
            localStorage.setItem('Presets', JSON.stringify(Presets));
        }

        // Load Presets
        function LoadPresets() {
            Presets = JSON.parse(localStorage.getItem('Presets') ?? '{}');
            let List = [];
            for (let i = 0; i < Object.keys(Presets).length; i++) {
                List.push(Object.keys(Presets)[i]);
            }
            const EditorPresets = b('EditorPresets');
            while (EditorPresets.firstChild) {
                EditorPresets.removeChild(EditorPresets.lastChild);
            }
            List.forEach(ele => {
                const option = document.createElement('option');
                option.value = ele;
                option.innerText = ele;
                EditorPresets.append(option);
            });
        }

        // Load the preset
        function LoadPreset() {
            const Value = b('EditorPresets').value;
            if (Value.length <= 0) {
                ShowNewPoll();
                ValidatePollOptions();
                return;
            }
            let Preset = Presets[Value];
            if (Preset != undefined) {
                const EditorOptions = b('EditorOptions');
                while (EditorOptions.firstChild) {
                    EditorOptions.removeChild(EditorOptions.lastChild);
                }
                b('Editor_PollQuestion').value = Preset.prompt;
                for (let i = 0; i < Preset.options.length; i++) { AddOption().value = Preset.options[i]; }
            }
            ShowNewPoll();
            ValidatePollOptions();
        }

        // Delete the preset
        function DeletePreset() {
            const Value = b('EditorPresets').value;
            let Preset = Presets[Value];
            if (Preset != undefined) {
                Presets[Value] = undefined;
                delete Preset;
                SaveToLocalStorage();
                ShowPresets();
            }
        }

        // We setup the current X buttons
        (function () {
            const EditorOptions = b('EditorOptions');
            while (EditorOptions.firstChild) {
                EditorOptions.removeChild(EditorOptions.lastChild);
            }
            AddOption(); AddOption();
            b('CreatePresetButton').addEventListener('click', (ev) => {
                const name = prompt("Enter a preset name. Any existing preset with the exact name will be replaced.", Presets_Loaded);
                if (name == null || name.length <= 0) return;
                let Preset = { "prompt": b('Editor_PollQuestion').value, "options": [] };
                const OptionInputs = b('EditorOptions').querySelectorAll("div > input");
                for (let i = 0; i < OptionInputs.length; i++) {
                    Preset.options.push(OptionInputs[i].value);
                }
                Presets[name] = Preset;
                SaveToLocalStorage();
            });
            b('CreatePresetButton').addEventListener('contextmenu', (ev) => {
                ev.preventDefault();
                ShowPresets();
            });
        })();

        let YTAccessToken = "";
        let YTChatID = "";
        let Retries = 4;
        let YTIsFetching = false;

        function CheckPollUpdates() {
            if (ConnectedYTPoll == "NONE") {
                console.warn("A poll isn't running anymore, ignoring request.");
                return;
            }
            if (YTIsFetching) // A bug that it sends more than one request at once. This is a workaround;
            {
                console.warn("A simultaneously operation was detected and prevented.");
                return;
            }
            YTIsFetching = true;
            return fetch('https://www.googleapis.com/youtube/v3/liveChat/messages?part=snippet&maxResults=200&liveChatId=' + YTChatID, { // No need for data, just IDs.
                "headers": {
                    "Authorization": "Bearer " + YTAccessToken,
                    "Accept": "application/json"
                }
            }).then(res => {
                YTIsFetching = false;
                if (!res.ok) {
                    console.warn("[YT] We are unable to access the live chat right now. We'll try again in 2 seconds.");
                    return Promise.reject("failed to update");
                }
                return res.json();
            }).then(json => {
                if (json.activePollItem != undefined && json.activePollItem.id == ConnectedYTPoll) { // Check if the poll is the same as the linked ID
                    SetYTPollRes(json.activePollItem);
                    setTimeout(CheckPollUpdates, json.pollingIntervalMillis); // Timeout in a polling interval according to YouTube.
                    return json.activePollItem;
                }
                if (Retries > 0) {
                    Retries--;
                    console.warn("[YT] Has not received poll item yet!");
                    return Promise.reject("no poll item received");
                }
                // No more poll... We'll no longer send requests and set the YT poll ID to none.
                ConnectedYTPoll = "NONE";
                console.warn("[YT] A poll isn't running in YouTube anymore, previous results will remain the same for this session")
                return null;
            }).catch(err => {
                YTIsFetching = false;
                console.warn("[YT] Request failed. Retrying in 2 seconds");
                if (ConnectedYTPoll != "NONE") setTimeout(CheckPollUpdates, 2000);
                return Promise.reject("failed to update");
            });
        }

        function LoadYTBroadcast(ID) {
            return fetch('https://youtube.googleapis.com/youtube/v3/liveBroadcasts?part=snippet&broadcastType=all&maxResults=1&id=' + ID, {
                "headers": {
                    "Authorization": "Bearer " + YTAccessToken,
                    "Accept": "application/json"
                }
            }).then(res => {
                if (res.status == 401) {
                    ReverifyPrompt(() => { LoadYTBroadcast(ID); });
                    return Promise.reject("User needs to re-verify");
                }
                return res.json();
            }).then(json => {
                if (json.items.length > 0) {
                    ConnectedYTPoll = "";
                    YTChatID = json.items[0].snippet.liveChatId;
                    console.log("[YT] Connected to broadcast!");
                    return CheckPollDetails();
                }
                return Promise.reject("No stream found!");
            }).catch(err => {
                console.error(err);
            });
        }

        function CheckPollDetails() {
            return fetch('https://www.googleapis.com/youtube/v3/liveChat/messages?part=id&maxResults=200&liveChatId=' + YTChatID, { // No need for data, just IDs.
                "headers": {
                    "Authorization": "Bearer " + YTAccessToken,
                    "Accept": "application/json"
                }
            }).then(res => {
                if (res.status == 403) {
                    return Promise.reject("We are unable to access the live chat. Please check your stream settings.");
                }
                return res.json();
            }).then(json => {
                console.log("[YT] Successfully connected to chat!")
                if (json.activePollItem != undefined) { // Poll Running
                    ConnectedYTPoll = json.activePollItem.id;
                }
                else {
                    ConnectedYTPoll = "NONE";
                }
            }).catch(err => {
                console.error(err);
            });
        }

        function ReverifyPrompt(event) {
            // Google's OAuth 2.0 endpoint for requesting an access token
            var link = new URL('https://accounts.google.com/o/oauth2/v2/auth');

            // Parameters to pass to OAuth 2.0 endpoint.
            link.search = '?' + new URLSearchParams({
                'client_id': '597860444523-l87m271jorgmc0a9ea2vnn4ohqkmjphi.apps.googleusercontent.com',
                'redirect_uri': (() => { let str = window.location.href; if (str.includes('?')) { str = str.split('?')[0]; } if (str.includes('#')) { str = str.split('#')[0]; } return str.replace('polling-new.html', 'launched-toreverify.html'); })(),
                'response_type': 'token',
                'scope': 'https://www.googleapis.com/auth/youtube.force-ssl',
                'state': 'ytreverify2'
            }).toString();
            let win = window.open(link, '_blank');
            if (!win || win.closed || typeof win.closed == 'undefined') {
                //POPUP BLOCKED
                alert("Uh oh! We gotta re-verify you. Open the popup that was blocked from your blocker and you'll be prompt to reverify.");
                let i = setInterval(() => {
                    if (localStorage.getItem('ytsavedtoken') != null) {
                        YTAccessToken = localStorage.getItem('ytsavedtoken');
                        event();
                        clearInterval(i);
                    }
                }, 1000);
            } else {
                let onmessage = (ev) => {
                    if (typeof ev.data === "object" && ev.data.type == "REVERIFIED") {
                        localStorage.setItem('ytsavedtoken', ev.data.retrieved);
                        YTAccessToken = localStorage.getItem('ytsavedtoken');
                        event();
                        window.removeEventListener('message', onmessage);
                    }
                }
                window.addEventListener('message', onmessage);
            }
        }

        function verifyYTToken(token) {
            fetch('https://www.googleapis.com/youtube/v3/channels?part=id&mine=true&access_token=' + token)
                .then(async result => {
                    if (!result.ok) return Promise.reject(await result.json());
                    YTAccessToken = token;
                    if (localStorage.getItem('saved_url') != null && localStorage.getItem('saved_url').length > 0) {
                        b("YouTubeURL").value = localStorage.getItem('saved_url');
                        LoadURL();
                    }
                    b('YUHandler').removeAttribute('onclick');
                    b('YUHandler').onclick = async (ev) => {
                        b('YUHandler').disabled = true;
                        b('YUHandler').innerText = "Checking Your Streams";
                        try {
                            let result = await fetch('https://youtube.googleapis.com/youtube/v3/liveBroadcasts?part=id&broadcastType=all&maxResults=1&mine=true', {
                                "headers": {
                                    "Authorization": "Bearer " + YTAccessToken,
                                    "Accept": "application/json"
                                }
                            });
                            let json = await result.json();
                            if (json.pageInfo.totalResults <= 0) {
                                b('YUHandler').disabled = false;
                                b('YUHandler').innerText = "NO STREAMS FOUND!";
                                setTimeout(() => { b('YUHandler').innerText = "Load from Recent"; }, 3000);
                            }
                            else {
                                b('YUHandler').disabled = false;
                                b('YUHandler').innerText = "Load from Recent";
                                b("YouTubeURL").value = 'https://youtube.com/live/' + json.items[0].id;
                                LoadURL();
                            }
                        } catch (error) {
                            console.error(error);
                            b('YUHandler').disabled = false;
                            b('YUHandler').innerText = "AN INTERNAL ERROR OCCURRED!";
                            setTimeout(() => { b('YUHandler').innerText = "Load from Recent"; }, 3000);
                        }
                    };
                    localStorage.setItem('ytsavedtoken', token);
                })
                .catch(err => {
                    console.error("YouTube Authentication Failed: ", err);
                    localStorage.removeItem('ytsavedtoken');
                    b('YouTubeConnection').innerHTML = "YouTube Authentication is required to continue.";
                    document.body.insertAdjacentHTML('beforebegin', `<ul id="AuthRequired2" style="padding: 3px; border-radius: 6px; border: thick solid; position: relative;" class="Oops"><img src="./cdn/HmmNotes-On_a_stack-7tv.gif"><span style="font-size: 16px; position: absolute; left: 110px; font-size: 24px;">Every hour, we need to reverify you to continue using this tool. Please visit the link again to reauthorize. Remember that we ONLY use the API for this tool:</span><button id="authorize" style="position: absolute; left: 110px; top: 65px; width: 92%;">Authorize YouTube (I acknowledge what I read above)</button></ul>`)
                    document.getElementById('authorize').onclick = (ev) => { YoutubeLinkHandler(); };
                });
        }

        // function openDetails()
        // {
        //     b("troll_features_dialog").open = true;
        // }

        function getElementClass(Class) {
            return document.getElementsByClassName(Class).length > 0 ? document.getElementsByClassName(Class)[0] : null;
        }

        function b(Id) {
            return document.getElementById(Id);
        }

        function GetRedemptionData(ID) {
            for (var i = 0; i < redemptions.length; i++) {
                if (redemptions[i].id == ID) {
                    return redemptions[i];
                }
            }
            return null;
        }

        function LoadCached() {
            if (localStorage.getItem("cached") != null) {
                redemptions = [];
                var b = (localStorage.getItem("cached")).split("~=~");
                b.forEach(ele => {
                    let a = JSON.parse(ele);
                    let date = new Date(a.redeemed_at);
                    if ((new Date().getTime() - date.getTime()) < 86400000) {
                        redemptions.push(a);
                    }
                });
                SaveCached();
            }
        }
        function SaveCached() {
            var array = [];
            redemptions.forEach(ele => {
                array.push(JSON.stringify(ele));
            });
            localStorage.setItem("cached", array.join("~=~"));
        }

        function AddRedemption(data) {
            if (!data.reviewed_at) {
                if (data.status != "unfulfilled") {
                    data.reviewed_at = new Date().toString();
                }
            }
            redemptions.unshift(data);
            SaveCached();
        }

        function UpdateRedemption(data) {
            if (!data.reviewed_at) {
                if (data.status != "unfulfilled") {
                    data.reviewed_at = new Date().toString();
                }
            }
            var A = -1;
            for (var i = 0; i < redemptions.length; i++) {
                if (redemptions[i].id == data.id) {
                    A = i;
                    break;
                }
            }
            if (A != -1) {
                redemptions[A] = data;
                SaveCached();
            }
        }

        let IntervalID = 0;

        function CheckPoll() {
            if (!ValidatePollOptions()) return;
            PE_Q = (b('Editor_PollQuestion').value || "Vote...");
            let Options = [];
            const OptionInputs = b('EditorOptions').querySelectorAll("div > input");
            for (let i = 0; i < OptionInputs.length; i++) {
                if (OptionInputs[i].value.length > 0) Options.push(OptionInputs[i].value);
            }
            PE_O = Options;
            if (PE_O.length < 2 || PE_O.length > 5) {
                alert("A poll must have 2-5 options.");
                return;
            }
            SubmitPoll();
        }

        function SubmitPoll() {
            let url = new URL('https://api.twitch.tv/helix/polls');
            let Options = [];
            for (var i = 0; i < PE_O.length; i++) {
                if (PE_O[i].length > 0) {
                    Options.push({ "title": PE_O[i].substring(0, 25) });
                }
            }
            b("CreatePollEditor").style = "display: none;";
            if (isNaN(Number.parseInt(b("Editor_PollDuration").value))) b("Editor_PollDuration").value = "60";
            // Twitch Submit Poll
            fetch(
                url,
                {
                    "method": "POST",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        "Content-Type": "application/json"
                    },
                    "body": JSON.stringify({
                        "broadcaster_id": user_id,
                        "title": PE_Q.substring(0, 60),
                        "choices": Options,
                        "duration": Number.parseInt(b("Editor_PollDuration").value)
                    })
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.data) {
                        log('Got Created Poll');
                        ConnectedPollID = resp.data[0].id;
                        console.log(resp.data);
                    } else {
                        console.error('Failed to create poll', resp);
                    }
                })
                .catch(err => {
                    console.log(err);
                    log(`Error with Polls Call Call: ${err.message ? err.message : ''}`);
                });
            // YT Submit Poll
            Options = [];
            for (var i = 0; i < PE_O.length; i++) {
                if (PE_O[i].length > 0) {
                    Options.push({ "optionText": PE_O[i].substring(0, 35) });
                }
            }
            fetch('https://www.googleapis.com/youtube/v3/liveChat/messages?part=snippet', { // No need for data, just IDs.
                "method": "POST",
                "headers": {
                    "Authorization": "Bearer " + YTAccessToken,
                    "Accept": "application/json"
                },
                "body": JSON.stringify({
                    "snippet": { "liveChatId": YTChatID, "type": "pollEvent", "pollDetails": { "metadata": { "options": Options, "questionText": PE_Q.substring(0, 100) } } }
                })
            }).then(res => {
                if (res.status == 401) {
                    ReverifyPrompt(SubmitPoll);
                    if (CheckForPolls) clearInterval(CheckForPolls);
                    return Promise.reject("User needs to re-verify");
                }
                return res.json();
            }).then(json => {
                ConnectedYTPoll = json.id;
                Retries = 2;
                SetYTPollRes(json);
                CheckPollUpdates();
            }).catch(err => {
                console.error(err);
            });
            SetPleaseWait("Waiting for YouTube & Twitch");
            var CheckForPolls = setInterval(() => {
                if (ConnectedPollID == "NONE" && ConnectedYTPoll != "NONE") {
                    SetPleaseWait("Waiting for Twitch");
                }
                if (ConnectedPollID != "NONE" && ConnectedYTPoll == "NONE") {
                    SetPleaseWait("Waiting for YouTube");
                }
                if (ConnectedPollID != "NONE" && ConnectedYTPoll != "NONE") {
                    clearInterval(CheckForPolls);
                    b("PleaseWait").style = "display: none;";
                    b("CurrentPoll").style = "";
                    window.scrollTo(0, document.body.scrollHeight);
                    IntervalIDForPoll = setInterval(UpdatePollResponses, 150);
                    // PollStarttime = new Date();
                    // PollEndtime = new Date();
                    // PollEndtime.setSeconds(PollEndtime.getSeconds() + Number.parseInt(b("Editor_PollDuration").value) - 1);
                }
            }, 250);
        }

        var PollEndtime;
        var PollStarttime;
        var IntervalIDForPoll = 0;

        function LoadURL() {
            let URL = b("YouTubeURL").value;
            localStorage.setItem("saved_url", URL);
            var regExp = /.*(?:youtu.be\/|v\/|u\/\w\/|live\/|watch\?v=)([^#\&\?]*).*/;
            try {
                b("YTChatDummyDoc").src = "https://youtube.com/live_chat?v=" + (URL.match(regExp)[1] ?? "none") + "&embed_domain=" + location.hostname;
                let OldText = b("YouTubeConnection").querySelector("span").innerHTML;
                if (!OldText.includes("invalid") && !OldText.includes("loaded")) {
                    LoadYTBroadcast((URL.match(regExp)[1] ?? "none"));
                    b("YouTubeConnection").querySelector("span").innerHTML = "YouTube Chat successfully loaded!";
                    b("YouTubeConnection").querySelector("span").style.color = "green";
                    setTimeout(() => {
                        b("YouTubeConnection").querySelector("span").innerHTML = OldText;
                        b("YouTubeConnection").querySelector("span").style.color = "";
                    }, 1000)
                }
            } catch (error) {
                console.error(error);
                let OldText = b("YouTubeConnection").querySelector("span").innerText;
                if (!OldText.includes("invalid") && !OldText.includes("loaded")) {
                    b("YouTubeConnection").querySelector("span").innerText = "Invalid YouTube URL!";
                    b("YouTubeConnection").querySelector("span").style.color = "red";
                    setTimeout(() => {
                        b("YouTubeConnection").querySelector("span").innerText = OldText;
                        b("YouTubeConnection").querySelector("span").style.color = "";
                    }, 1000)
                }
            }
        }

        function UpdatePollResponses() {
            b("PollOption3").style = PE_O.length >= 3 ? "" : "display: none;";
            b("PPollOption3").parentElement.style = PE_O.length >= 3 ? "" : "display: none;";
            b("PollOption4").style = PE_O.length >= 4 ? "" : "display: none;";
            b("PPollOption4").parentElement.style = PE_O.length >= 4 ? "" : "display: none;";
            b("PollOption5").style = PE_O.length >= 5 ? "" : "display: none;";
            b("PPollOption5").parentElement.style = PE_O.length >= 5 ? "" : "display: none;";
            // Timer
            var Now = new Date().getTime();
            var distance = PollEndtime.getTime() - Now;
            if (distance >= 0) {
                b("PPollDuration").style.width = ((1 - ((Now - PollStarttime.getTime()) / (PollEndtime.getTime() - PollStarttime.getTime()))) * 100) + "%";
                var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                var seconds = Math.floor((distance % (1000 * 60)) / 1000);
                b("PollDuration").innerText = ('0' + minutes).substring((minutes).toString().length - 1) + ":" + ('0' + seconds).substring((seconds).toString().length - 1);
            }

            if ((typeof TwitchPoll === 'object' && TwitchPoll != null) && (typeof YouTubePoll === 'object' && YouTubePoll != null)) {
                var CombinedVotes = Array(PE_O.length);
                var TwitchTotalVotes = 0;
                const YouTubeTotalVotes = YouTubePoll["Total"];
                for (let i = 0; i < TwitchPoll["votes"].length; i++) {
                    TwitchTotalVotes += TwitchPoll["votes"][i];
                    CombinedVotes[i] = TwitchPoll["votes"][i];
                }
                for (let i = 0; i < YouTubePoll["votes"].length; i++) {
                    CombinedVotes[i] += YouTubePoll["votes"][i];
                }
                const CombinedTotal = TwitchTotalVotes + YouTubeTotalVotes;
                getElementClass("PollQ").innerText = PE_Q + " (" + CombinedTotal + " Votes)";
                for (let i = 0; i < CombinedVotes.length; i++) {
                    b("PPollOption" + (i + 1)).style.width = `${Math.round(CombinedVotes[i] / ((CombinedTotal == 0) ? 1 : CombinedTotal) * 100)}%`;
                    b("PollOption" + (i + 1)).innerText = `${PE_O[i]} / ${Math.round(CombinedVotes[i] / ((CombinedTotal == 0) ? 1 : CombinedTotal) * 100)}% (${CombinedVotes[i]})`;
                }
            }
        }

        function EndPollEarly(AllowYouTubeEvents = false) {
            let url = new URL('https://api.twitch.tv/helix/polls');
            let Options = [];
            for (var i = 0; i < PE_O.length; i++) {
                if (PE_O[i].length > 0) {
                    Options.push({ "title": PE_O[i] });
                }
            }

            if (ConnectedYTPoll != "NONE" && !AllowYouTubeEvents) {
                fetch(`https://content-youtube.googleapis.com/youtube/v3/liveChat/messages/transition?id=${ConnectedYTPoll}&status=closed`, { // End the poll, no matter the response result...
                    "method": "POST",
                    "headers": {
                        "Authorization": "Bearer " + YTAccessToken,
                        "Accept": "application/json"
                    }
                }).then(res => {
                    ConnectedYTPoll = "NONE";
                }).catch(err => {
                    console.error(err);
                });
                ConnectedYTPoll = "ENDING"; // So the Twitch one won't end and give an error.
            }
            if (ConnectedPollID != "NONE") {
                fetch(
                    url,
                    {
                        "method": "PATCH",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            "Content-Type": "application/json"
                        },
                        "body": JSON.stringify({
                            "broadcaster_id": user_id,
                            "id": ConnectedPollID,
                            "status": "TERMINATED"
                        })
                    }
                )
                    .then(resp => resp.json())
                    .then(resp => {
                        if (!resp.data) {
                            return Promise.reject('Failed to end poll');
                        }
                    })
                    .catch(err => {
                        console.log(err);
                        log(`Error with Polls Call Call: ${err.message ? err.message : ''}`);
                    });
            }
            b("CurrentPoll").style = "display: none;";
            b("PollWarning").style = "display: none;";
            SetPleaseWait("Ending YouTube & Twitch polls");
            var CheckForPolls = setInterval(() => {
                if (ConnectedPollID != "NONE" && ConnectedYTPoll == "NONE") {
                    SetPleaseWait("Ending Twitch poll");
                }
                else if (ConnectedPollID == "NONE" && ConnectedYTPoll != "NONE") {
                    SetPleaseWait("Ending YouTube poll");
                }
                else if (ConnectedPollID == "NONE" && ConnectedYTPoll == "NONE") {
                    clearInterval(CheckForPolls);
                    b("PleaseWait").style = "display: none;";
                    b("CreatePollEditor").style = "";
                    b('Create').style = "";
                    b('NewEditor').style = "display: none;";
                    b('GetPresets').style = "display: none;";
                }
            }, 250);
        }

        function SetYTPollRes(json) {
            let Votes = [];
            let Total = 0;
            let arr = json.snippet.pollDetails.metadata.options;
            for (let i = 0; i < arr.length; i++) {
                const tally = arr[i].tally.replaceAll(',', "").replaceAll('.', "");
                const votes = parseInt(tally);
                if (isNaN(votes)) {
                    console.error("[YT] Failed to parse tally for " + arr[i].optionText);
                    Votes.push(0);
                    continue;
                }
                Total += votes;
                Votes.push(votes);
            }
            //console.log("DEBUG VOTES", Votes, Total);
            SetYouTubePoll(Votes, Total);
        }

        function processToken(token) {
            access_token = token;
            fetch(
                'https://api.twitch.tv/helix/users',
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.error != undefined) {
                        return Promise.reject(resp.error + ": " + resp.message);
                    }
                    if (window.location.hash.length > 0) window.location.hash = "#authorized";
                    localStorage.setItem("saved_access_token", token);
                    document.getElementById("AuthRequired").remove();
                    b("TwitchChatDummyDoc").src = "https://www.twitch.tv/embed/" + resp.data[0].login + "/chat?parent=seenwonderalex.github.io"
                    SetPleaseWait("Waiting for YouTube & Twitch");
                    let Val = 0;
                    var CheckForPolls = setInterval(() => {
                        if (b("TwitchChatDummyDoc").src == "about:blank" || b("YTChatDummyDoc").src == "about:blank") {
                            SetPleaseWait("Waiting for " + ((b("TwitchChatDummyDoc").src == "about:blank" && b("YTChatDummyDoc").src == "about:blank") ? "YouTube & Twitch" : ((b("YTChatDummyDoc").src == "about:blank") ? "YouTube" : "Twitch")));
                            return;
                        }
                        if (ConnectedPollID.length <= 0 && ConnectedYTPoll.length <= 0) {
                            SetPleaseWait("Checking active polls for YouTube & Twitch");
                        }
                        if (ConnectedPollID.length > 0 && ConnectedYTPoll.length <= 0) {
                            SetPleaseWait(Val >= 40 ? "On youtube.com, check if you're logged in to your streaming account. As well as having the Compatibility Extension" : "Checking active polls for YouTube");
                            Val++;
                        }
                        if (ConnectedPollID.length <= 0 && ConnectedYTPoll.length > 0) {
                            SetPleaseWait("Checking active polls for Twitch");
                        }
                        if (ConnectedPollID.length > 0 && ConnectedYTPoll.length > 0) {
                            clearInterval(CheckForPolls);
                            b("PleaseWait").style = "display: none;";
                            if (ConnectedPollID == "NONE" && ConnectedYTPoll == "NONE") {
                                b("CreatePollEditor").style = "";
                                b('Create').style = "";
                                b('NewEditor').style = "display: none;";
                                b('GetPresets').style = "display: none;";
                            }
                            if (ConnectedPollID != "NONE" && ConnectedYTPoll == "NONE") {
                                b("PollWarning").style = "";
                                getElementClass("PollWarningText").innerText = "You currently have an active poll for Twitch. Do you want to continue creating a multistreaming Poll & end Twitch poll?";
                            }
                            if (ConnectedPollID == "NONE" && ConnectedYTPoll != "NONE") {
                                b("PollWarning").style = "";
                                getElementClass("PollWarningText").innerText = "You currently have an active poll for YouTube. Do you want to continue creating a multistreaming Poll & end YouTube poll?";
                            }
                            if (ConnectedPollID != "NONE" && ConnectedYTPoll != "NONE") {
                                b("PollWarning").style = "";
                                getElementClass("PollWarningText").innerText = "You currently have an active poll for both platforms. Do you want to continue creating a multistreaming Poll & end both polls?";
                            }
                        }
                    }, 250)
                    socket_space = new initSocket(true);
                    // and build schnanaigans
                    socket_space.on('connected', (id) => {
                        log(`Connected to WebSocket with ${id}`);
                        session_id = id;
                        user_id = resp.data[0].id;
                        checkPolls(resp.data[0].id);
                        requestHooks(resp.data[0].id);
                    });

                    // socket_space.on('session_keepalive', () => {
                    //     console.log("New Keepalive: " + new Date());
                    // });

                    socket_space.on('channel.poll.begin', (msg) => {
                        let { metadata, payload } = msg;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Start Poll event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        PastMessageIDs.push(metadata.message_id);
                        let { event } = payload;
                        ConnectedPollID = event.id;
                        PollStarttime = new Date(event.started_at);
                        PollEndtime = new Date(event.ends_at);
                        SetTwitchPoll(event, true);
                        b('PollResultsDiv').open = false;
                    });
                    socket_space.on('channel.poll.progress', (msg) => {
                        let { metadata, payload } = msg;
                        let { event } = payload;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Progress Poll event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        PastMessageIDs.push(metadata.message_id);
                        ConnectedPollID = event.id;
                        SetTwitchPoll(event);
                    });
                    socket_space.on('channel.poll.end', (msg) => {
                        let { metadata, payload } = msg;
                        let { event } = payload;
                        let { id } = event;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored End Poll event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        PastMessageIDs.push(metadata.message_id);
                        if (id != ConnectedPollID) {
                            console.error("Ignored End Poll event since the current Poll ID does not match with the event (this is due to Twitch probably re-sending events)")
                            return;
                        }
                        SetTwitchPoll(event);
                        b('PollResultsDiv').style = "";
                        b("CurrentPoll").style = "display: none;";
                        clearInterval(IntervalIDForPoll);
                        CalculateResults();
                        ConnectedPollID = "NONE";
                        // I realized that the poll results aren't finalized right away because the API has like a 2 second delay. We'll have to delay the request.
                        setTimeout(() => {
                            if (ConnectedYTPoll != "NONE" && ConnectedYTPoll != "ENDING") {
                                fetch(`https://content-youtube.googleapis.com/youtube/v3/liveChat/messages/transition?part=snippet&id=${ConnectedYTPoll}&status=closed`, { // End the poll, no matter the response result...
                                    "method": "POST",
                                    "headers": {
                                        "Authorization": "Bearer " + YTAccessToken,
                                        "Accept": "application/json"
                                    }
                                }).then(async res => {
                                    try {
                                        ConnectedYTPoll = "NONE";
                                        b("CreatePollEditor").style = "";
                                        b('Create').style = "";
                                        b('NewEditor').style = "display: none;";
                                        b('GetPresets').style = "display: none;";
                                        SetYTPollRes(await res.json());
                                    } finally {
                                        CalculateResults();
                                    }
                                }).catch(err => {
                                    console.error(err);
                                });
                            }
                        }, 2000);
                    });
                    socket_space.on('channel.channel_points_custom_reward_redemption.add', (msg) => {
                        let { metadata, payload } = msg;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Add Redemption event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        if (GetRedemptionData(payload.event.id) != null) {
                            console.error("Ignored Add Redemption event due to duplicate redemption IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        AddRedemption(payload.event);
                    });
                    socket_space.on('channel.channel_points_custom_reward_redemption.update', (msg) => {
                        let { metadata, payload } = msg;
                        let { event } = payload;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Update Status event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        if (GetRedemptionData(payload.event.id) == null) {
                            AddRedemption(payload.event);
                            return;
                        }
                        UpdateRedemption(payload.event);
                    });
                })
                .catch(err => {
                    console.error(err);
                    log('Error with Users Call');
                    localStorage.removeItem("saved_access_token");
                    document.getElementById("AuthRequired").style = '';
                    b("AuthRequired").className = "Oops";
                    b("AuthRequired").getElementsByTagName('img')[0].src = './cdn/Weirdge-perry8782-7tv.gif';
                    b("AuthRequired").getElementsByTagName('span')[0].innerText = "We could not access your Twitch account anymore. " + err;
                    b("authorize").innerText = "Reauthorize Twitch";
                });
        }

        let PastMessageIDs = [];
        var SPAM_AMOUNT = 0;
        var LAST_TIME = new Date();

        function CalculateResults() {
            b("Res_PollOption3").style = PE_O.length >= 3 ? "" : "display: none;";
            b("Res_PollOption4").style = PE_O.length >= 4 ? "" : "display: none;";
            b("Res_PollOption5").style = PE_O.length >= 5 ? "" : "display: none;";
            if ((typeof TwitchPoll === 'object' && TwitchPoll != null) && (typeof YouTubePoll === 'object' && YouTubePoll != null)) {
                b('PollResultsDiv').open = true;
                b("RPOpt1_TTV").parentElement.style = "display: flex;";
                b("RPOpt2_TTV").parentElement.style = "display: flex;";
                b("RPOpt3_TTV").parentElement.style = PE_O.length >= 3 ? "display: flex;" : "display: flex; display: none;";
                b("RPOpt4_TTV").parentElement.style = PE_O.length >= 4 ? "display: flex;" : "display: flex; display: none;";
                b("RPOpt5_TTV").parentElement.style = PE_O.length >= 5 ? "display: flex;" : "display: flex; display: none;";

                var CombinedVotes = Array(PE_O.length);
                var TwitchTotalVotes = 0;
                const YouTubeTotalVotes = YouTubePoll["Total"];
                for (let i = 0; i < TwitchPoll["votes"].length; i++) {
                    TwitchTotalVotes += TwitchPoll["votes"][i];
                    CombinedVotes[i] = TwitchPoll["votes"][i];
                }
                for (let i = 0; i < YouTubePoll["votes"].length; i++) {
                    CombinedVotes[i] += YouTubePoll["votes"][i];
                }
                const CombinedTotal = TwitchTotalVotes + YouTubeTotalVotes;
                b("Res_PollQuestion").innerText = PE_Q
                b("Res_PollQuestionInfo").innerText = " (" + CombinedTotal + " Votes) T: " + TwitchTotalVotes + " Y: " + YouTubeTotalVotes;
                for (let i = 0; i < CombinedVotes.length; i++) {
                    b("Res_PollOption" + (i + 1)).innerText = `${PE_O[i]} / ${Math.round(CombinedVotes[i] / ((CombinedTotal == 0) ? 1 : CombinedTotal) * 100)}% (${CombinedVotes[i]}) T: ${TwitchPoll["votes"][i]} Y: ${YouTubePoll["votes"][i]}`;
                    if (TwitchPoll["votes"][i] == 0 && YouTubePoll["votes"][i] > 0) {
                        b('RPOpt' + (i + 1) + "_TTV").style.width = "0%";
                        b('RPOpt' + (i + 1) + "_YT").style.borderTopLeftRadius = "25px";
                        b('RPOpt' + (i + 1) + "_YT").style.borderBottomLeftRadius = "25px";
                        b('RPOpt' + (i + 1) + "_YT").style.width = Math.round((YouTubePoll["votes"][i] / CombinedTotal) * 100) + "%";
                    }
                    else if (TwitchPoll["votes"][i] > 0 && YouTubePoll["votes"][i] == 0) {
                        b('RPOpt' + (i + 1) + "_YT").style.width = "0%";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderTopRightRadius = "25px";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderBottomRightRadius = "25px";
                        b('RPOpt' + (i + 1) + "_TTV").style.width = Math.round((TwitchPoll["votes"][i] / CombinedTotal) * 100) + "%";
                    }
                    else {
                        b('RPOpt' + (i + 1) + "_YT").style.borderTopLeftRadius = "0";
                        b('RPOpt' + (i + 1) + "_YT").style.borderBottomLeftRadius = "0";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderTopRightRadius = "0";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderBottomRightRadius = "0";
                        b('RPOpt' + (i + 1) + "_TTV").style.width = Math.round((TwitchPoll["votes"][i] / CombinedTotal) * 100) + "%";
                        b('RPOpt' + (i + 1) + "_YT").style.width = Math.round((YouTubePoll["votes"][i] / CombinedTotal) * 100) + "%";
                    }
                }
                window.scrollTo(0, document.body.scrollHeight);
            }
        }

        function log(Message) {
            console.log(Message);
        }

        function YoutubeLinkHandler() {
            // Google's OAuth 2.0 endpoint for requesting an access token
            var oauth2Endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';

            // Create <form> element to submit parameters to OAuth 2.0 endpoint.
            var form = document.createElement('form');
            form.setAttribute('method', 'GET'); // Send as a GET request.
            form.setAttribute('action', oauth2Endpoint);

            // Parameters to pass to OAuth 2.0 endpoint.
            var params = {
                'client_id': '597860444523-l87m271jorgmc0a9ea2vnn4ohqkmjphi.apps.googleusercontent.com',
                'redirect_uri': (() => { let str = window.location.href; if (str.includes('?')) { str = str.split('?')[0]; } if (str.includes('#')) { str = str.split('#')[0]; } return str; })(),
                'response_type': 'token',
                'scope': 'https://www.googleapis.com/auth/youtube.force-ssl',
                'include_granted_scopes': 'true',
                'state': 'yt35hv1'
            };

            // Add form parameters as hidden input values.
            for (var p in params) {
                var input = document.createElement('input');
                input.setAttribute('type', 'hidden');
                input.setAttribute('name', p);
                input.setAttribute('value', params[p]);
                form.appendChild(input);
            }

            // Add form to page and submit it to open the OAuth 2.0 endpoint.
            document.body.appendChild(form);
            form.submit();
        }

        function requestHooks(user_id) {
            let topics = {
                'channel.poll.begin': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.poll.progress': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.poll.end': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.channel_points_custom_reward_redemption.add': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.channel_points_custom_reward_redemption.update': { version: '1', condition: { broadcaster_user_id: user_id } }
            }
            // if (ENABLE_SPAM_PROTECTION) {
            //     topics['channel.ban'] = { version: '1', condition: { broadcaster_user_id: user_id } };
            //     topics['channel.chat.message'] = { version: '1', condition: { broadcaster_user_id: user_id, user_id: user_id } };
            // }

            log(`Spawn Topics for ${user_id}`);

            for (let type in topics) {
                log(`Attempt create ${type} - ${user_id}`);
                let { version, condition } = topics[type];

                fetch(
                    'https://api.twitch.tv/helix/eventsub/subscriptions',
                    {
                        "method": "POST",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            'Content-Type': 'application/json'
                        },
                        "body": JSON.stringify({
                            type,
                            version,
                            condition,
                            transport: {
                                method: "websocket",
                                session_id
                            }
                        })
                    }
                )
                    .then(resp => resp.json())
                    .then(resp => {
                        if (resp.error) {
                            log(`Error with eventsub Call ${type} Call: ${resp.message ? resp.message : ''}`);
                        } else {
                            log(`Created ${type}`);
                            if (type == "channel.channel_points_custom_reward_redemption.add") {
                                LoadCached();
                            }
                        }
                    })
                    .catch(err => {
                        console.log(err);
                        log(`Error with eventsub Call ${type} Call: ${err.message ? err.message : ''}`);
                    });
            }
        }





        function checkPolls(broadcaster_id) {
            console.log('Get Existing Poll');

            let url = new URL('https://api.twitch.tv/helix/polls');
            let params = {
                broadcaster_id
            };
            url.search = new URLSearchParams(params).toString();

            fetch(
                url,
                {
                    "method": "GET",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Accept': 'application/json'
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.data && resp.data.length > 0) {
                        log('Got Poll');
                        if (resp.data[0].status == "ACTIVE") {
                            ConnectedPollID = resp.data[0].id;
                        }
                        else {
                            ConnectedPollID = "NONE";
                        }
                    } else {
                        log('No Polls Available');
                        ConnectedPollID = "NONE";
                    }
                })
                .catch(err => {
                    console.log(err);
                    log(`Error with Polls Call Call: ${err.message ? err.message : ''}`);
                });
        }

        let TwitchPoll;

        function SetTwitchPoll(JSON, MissingVotes = false) {
            try {
                let TP_Options = [];
                for (let index = 0; index < PE_O.length; index++) {
                    if (PE_O[index].length > 0) {
                        TP_Options.push(MissingVotes ? 0 : JSON.choices[index].votes);
                    }
                }
                TwitchPoll = { "votes": TP_Options }
            } catch (error) {
                console.log(error);
            }

        }

        let YouTubePoll;

        function SetYouTubePoll(Votes, Total) {
            YouTubePoll = { "votes": Votes, "Total": Total };
        }

        var PleaseWaitInterval = -1;

        var PWText = "";
        var PleaseWaitText = document.getElementsByClassName('PleaseWait')[0];

        function SetPleaseWait(TextToInput) {
            b('PleaseWait').style = "";
            if (PWText == TextToInput) return;
            PWText = TextToInput;
            PleaseWaitText.innerText = TextToInput + EllipsisText[Ellipsis];
            if (PleaseWaitInterval == -1) {
                PleaseWaitInterval = setInterval(() => {
                    if (Ellipsis < 3) {
                        Ellipsis++;
                    }
                    else {
                        Ellipsis = 0;
                    }
                    if (b('PleaseWait').style.display == "none") { clearInterval(PleaseWaitInterval); PleaseWaitInterval = -1; }
                    if (document.hidden) return;
                    PleaseWaitText.innerText = PWText + EllipsisText[Ellipsis];
                }, 200)
            }
        }

        var PE_Q = '';
        var PE_O = ['', '', '', '']

        function Editor_SetPollDetails(Question = "", Option1 = "", Option2 = "", Option3 = "", Option4 = "") {
            PE_Q = Question.length > 0 ? Question : "Vote...";
            PE_O[0] = Option1.length > 0 ? Option1 : "Yes";
            PE_O[1] = Option2.length > 0 ? Option2 : "No";
            PE_O[2] = Option3;
            PE_O[3] = Option4;
        }
        Editor_SetPollDetails();
    </script>
</body>

</html>