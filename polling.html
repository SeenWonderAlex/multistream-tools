<html>

<head>
    <title>Multistream Tools - Polling</title>
    <link rel="stylesheet" href="./style.css" />
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <style>
        #log {
            box-sizing: border-box;
            padding: 5px;
            width: 100%;
            height: 300px;
            overflow: auto;
            border: 1px solid #FFFFFF;
            border-radius: 20px;

            margin-bottom: 20px;
        }

        #log span {
            margin-right: 5px;
        }

        #subscriptions_refresh {
            cursor: pointer;
        }

        table {
            width: 100%;
        }
    </style>

    <style rel="stylesheet">
        #goals {
            /*position: absolute;*/
            bottom: 0px;
            left: 0px;
            right: 0px;
            background: darkred;
            color: palegoldenrod;
        }

        .goal {
            height: 50px;
            margin: 5px;
            background: red;
        }

        .goal_outer {
            position: relative;
            width: 100%;
            background: white;
            height: 50px;
        }

        .goal_inner {
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            background: yellow;
        }

        .goal_text_section {
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            line-height: 50px;
            font-size: 40px;
            color: #000000;
            text-align: center;
            background: transparent;
        }

        .goal_text_section span {
            margin: 0px 5px;
            color: #000000;
            background: transparent;
        }
    </style>
</head>

<body>
    
    <ul id="NewBeta">
        <img src="./cdn/BOOBA.webp">
        <span>An extension-less of this tool is now in BETA!</span>
        <ul>This includes:</ul>
        <ul class="a">- Accurate Vote Responses from YouTube itself (high amounts were predicted by percentage)</ul>
        <ul class="a">- An easy way to create a poll directly with 2-4 options</ul>
        <ul class="a">- Ability to add/load poll presets</ul>
        <button onclick="if (confirm('This is currently in testing phase. The YouTube Authentication app has not been verified, so we can only test this with a small amount of users. If you want to participate, please contact swagamesofficial@gmail.com')) location.href='./polling-new.html'">Try It Out!</button>
    </ul>
    <ul id="AuthRequired" style="display: none;">
        <img src="./cdn/HmmNotes-On_a_stack-7tv.gif">
        <span>Let's get you to authorize this website! We'll ask you to approve some permissions as well the app itself.
            You can always revoke our permissions later in your Twitch settings.</span>
        <button id="authorize">Authorize Twitch</button>
    </ul>

    <dialog id="yes_or_no_confirmation">
        <p>It looks like you're going to run a YES or NO poll. Are you sure this is the poll you're creating?</p>
        <br>
        <form method="dialog">
            <button onclick="SubmitPoll()">Yes & Run Poll</button>
            <br>
            <br>
            <button class="SubmitPoll">No & Edit Poll</button>
        </form>
    </dialog>

    <details id="YouTubeConnection" open>
        <summary>Connect with YouTube</summary>
        <span>Type your YouTube Stream URL in order to connect with YouTube. Make sure you have the <a
                style="text-decoration: none;" href="./download-extension/">YouTube
                Compatibility Extension</a>.</span>
        <br>
        <input id="YouTubeURL" class="YU1" type="url">
        <button onclick="LoadURL();" class="YU2">Load</button>
        <button onclick="YoutubeLinkHandler();" id="YUHandler" class="YU2 YU3">Load from Recent</button>
    </details>

    <iframe id="TwitchChatDummyDoc" src="about:blank" height="450"
        sandbox="allow-storage-access-by-user-activation allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-modals"></iframe>
    <iframe id="YTChatDocument" src="about:blank" height="450"></iframe>

    <div id="CurrentPoll" style="display: none;">
        <span class="PollQuestion PollQ">Poll Question</span>
        <p id="PollOption1" class="PollOption">0%</p>
        <div class="PollProgress">
            <div id="PPollOption1" class="PollProgressBar"></div>
        </div>
        <p id="PollOption2" class="PollOption">0%</p>
        <div class="PollProgress">
            <div id="PPollOption2" class="PollProgressBar"></div>
        </div>
        <p id="PollOption3" class="PollOption" style="display: none;">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="PPollOption3" class="PollProgressBar"></div>
        </div>
        <p id="PollOption4" class="PollOption" style="display: none;">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="PPollOption4" class="PollProgressBar"></div>
        </div>
        <br>
        <br>
        <div class="PollProgress">
            <div id="PPollDuration" class="PollProgressBar RedColor"></div>
        </div>
        <p id="PollDuration">00:00</p>
        <button class="SubmitPoll" onclick="EndPollEarly(true)">End Polls Early</button>
    </div>

    <div id="PleaseWait" style="display: none;">
        <span class="PleaseWait">Checking for active polls</span>
    </div>

    <div id="PollWarning" style="display: none;">
        <span class="PollWarningText">You currently have an active poll. Do you want to continue creating a
            multistreaming Poll & end other poll(s)?</span>
        <br>
        <button class="SubmitPoll" onclick="EndPollEarly(false)">Continue & End Poll(s)</button>
    </div>

    <div id="CreatePollEditor" style="display: none;">
        <span>Use the YouTube chat to fill out the poll options. Click the Create Poll button below to start a poll in
            both chats!</span>
        <br>
        <label for="Editor_PollDuration">Poll Duration:</label>
        <select name="Editor_PollDuration" id="Editor_PollDuration">
            <option value="30">30 Seconds</option>
            <option value="60">1 Minute</option>
            <option value="120">2 Minutes</option>
            <option value="300">5 Minutes</option>
            <option value="900">15 Minutes</option>
            <option value="1800">30 Minutes</option>
        </select>
        <br>
        <button onclick="CheckPoll()">Create Poll</button>
    </div>

    <details id="PollResultsDiv" open style="display: none;">
        <summary>Poll Results</summary>
        <span class="PollQuestion" id="Res_PollQuestion">Poll Question</span>
        <span class="PollQuestionInfo" id="Res_PollQuestionInfo"> (0 Votes)</span>
        <p id="Res_PollOption1" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt1_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt1_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
        <p id="Res_PollOption2" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt2_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt2_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
        <p id="Res_PollOption3" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt3_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt3_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
        <p id="Res_PollOption4" class="PollOption">0%</p>
        <div class="PollProgress" style="display: none;">
            <div id="RPOpt4_TTV" class="PollProgressBarResult"
                style="border-top-left-radius: 25px; border-bottom-left-radius: 25px; width: 0%; background-color: rgb(96, 53, 197);">
            </div>
            <div id="RPOpt4_YT" class="PollProgressBarResult"
                style="border-top-right-radius: 25px; border-bottom-right-radius: 25px; width: 0%; background-color: rgb(222, 46, 46);">
            </div>
        </div>
    </details>

    <!-- <details id="SpamProtectionDetailed" style="display: none;" open>
        <summary>Mod Settings</summary>
        <label class="switch">
            <input type="checkbox" checked id="ModSpamProtection">
            <span class="slider round"></span>
        </label>
        <br>
        <span>Killa Spam Protection</span>
    </details> -->

    <script type="text/javascript" src="./eventsub.js"></script>
    <script type="text/javascript">
        // These are set for the GitHub Pages Example
        // Substitute as needed
        var client_id = 'siayiyd16jh90e3j473ckuu2seoq0p';
        var redirect = (() => { let str = window.location.href; if (str.includes('?')) { str = str.split('?')[0]; } if (str.includes('#')) { str = str.split('#')[0]; } return str; })();
        var access_token = '';
        var socket_space = '';
        var session_id = '';
        var user_id = '';

        var ConnectedPollID = '';
        var ConnectedYTPoll = '';

        // const ENABLE_SPAM_PROTECTION = false;
        // let SPAM_PROTECTION_CHECKED = true;

        // Ellipsis Check
        var Ellipsis = 0;
        var redemptions = [];
        const EllipsisText = ["", ".", "..", "..."]

        // document.getElementById('authorize').setAttribute('href', 'https://id.twitch.tv/oauth2/authorize?client_id=' + client_id + '&redirect_uri=' + encodeURIComponent(redirect) + '&response_type=token&scope=user:read:chat+channel:moderate+moderator:manage:banned_users+channel:manage:moderators+moderation:read+channel:read:redemptions+channel:manage:polls+channel:read:polls+moderator:read:chat_settings');
        document.getElementById('authorize').onclick = (ev) => { location.href = 'https://id.twitch.tv/oauth2/authorize?client_id=' + client_id + '&redirect_uri=' + encodeURIComponent(redirect) + '&response_type=token&scope=chat:read+channel:moderate+moderation:read+channel:read:redemptions+channel:manage:polls+channel:read:polls+moderator:read:chat_settings&state=ttv3e43v1' };
        document.addEventListener('DOMContentLoaded', () => {
            handleSavedToken();
        });
        function handleSavedToken() {
            const urlParams = new URLSearchParams(window.location.hash.replace('#', '?'));
            const myParam = urlParams.get('access_token');
            const isTwitch = urlParams.get('state') == "ttv3e43v1";
            const isYouTube = urlParams.get('state') == "yt35hv1";
            if (myParam != null && isTwitch) {
                processToken(myParam);
            }
            else if (localStorage.getItem('saved_access_token') != null) {
                processToken(localStorage.getItem('saved_access_token'));
            }
            else {
                const queryParams = new URLSearchParams(window.location.search);
                const error = queryParams.get('error');
                if (error != null) {
                    b("AuthRequired").className = "Oops";
                    b("AuthRequired").getElementsByTagName('img')[0].src = './cdn/Weirdge-perry8782-7tv.gif';
                    let Text = "We could not complete the authentication of your Twitch account: " + queryParams.get('error_description');
                    if (error == "access_denied") {
                        Text = "Don't like the permissions we have? No worries. Contact SeenWonderAlex and he'll give you permissions you need.";
                    }
                    else if (error == "redirect_mismatch") {
                        Text = "Are you in the right page? We are unable to complete this process. Feel free to try again or reopen this page from the source.";
                    }
                    b("AuthRequired").getElementsByTagName('span')[0].innerText = Text;
                    b("authorize").innerText = "Reauthorize Twitch";
                }
                document.getElementById("AuthRequired").style = '';
            }

            if (myParam != null && isYouTube) {
                verifyYTToken(myParam);
            }
            else if (localStorage.getItem('ytsavedtoken') != null) {
                verifyYTToken(localStorage.getItem('ytsavedtoken'));
            }
            else {
                b('YUHandler').innerText = "Load from Recent (authorization required)";
                b('YUHandler').setAttribute('onclick', "YoutubeLinkHandler();")
            }

            if (localStorage.getItem('saved_url') != null && localStorage.getItem('saved_url').length > 0) {
                b("YouTubeURL").value = localStorage.getItem('saved_url');
                LoadURL();
            }
        }

        function verifyYTToken(token) {
            fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true&access_token=' + token)
                .then(async result => {
                    if (!result.ok) return Promise.reject(await result.json());
                    b('YUHandler').removeAttribute('onclick');
                    b('YUHandler').onclick = async (ev) => {
                        b('YUHandler').disabled = true;
                        b('YUHandler').innerText = "Checking Your Streams";
                        try {
                            let result = await fetch('https://youtube.googleapis.com/youtube/v3/liveBroadcasts?part=id&broadcastType=all&maxResults=1&mine=true', {
                                "headers": {
                                    "Authorization": "Bearer " + token,
                                    "Accept": "application/json"
                                }
                            });
                            let json = await result.json();
                            if (json.pageInfo.totalResults <= 0) {
                                b('YUHandler').disabled = false;
                                b('YUHandler').innerText = "NO STREAMS FOUND!";
                                setTimeout(() => { b('YUHandler').innerText = "Load from Recent"; }, 3000);
                            }
                            else {
                                b('YUHandler').disabled = false;
                                b('YUHandler').innerText = "Load from Recent";
                                b("YouTubeURL").value = 'https://youtube.com/live/' + json.items[0].id;
                                LoadURL();
                            }
                        } catch (error) {
                            console.error(error);
                            b('YUHandler').disabled = false;
                            b('YUHandler').innerText = "AN INTERNAL ERROR OCCURRED!";
                            setTimeout(() => { b('YUHandler').innerText = "Load from Recent"; }, 3000);
                        }
                    };
                    localStorage.setItem('ytsavedtoken', token);
                })
                .catch(err => {
                    console.error("YouTube Authentication Failed: " + err);
                    localStorage.removeItem('ytsavedtoken');
                    b('YUHandler').innerText = "Load from Recent (authorization required)";
                    b('YUHandler').setAttribute('onclick', "YoutubeLinkHandler();")
                });
        }

        // function openDetails()
        // {
        //     b("troll_features_dialog").open = true;
        // }

        function getElementClass(Class) {
            return document.getElementsByClassName(Class).length > 0 ? document.getElementsByClassName(Class)[0] : null;
        }

        function b(Id) {
            return document.getElementById(Id);
        }

        function GetRedemptionData(ID) {
            for (var i = 0; i < redemptions.length; i++) {
                if (redemptions[i].id == ID) {
                    return redemptions[i];
                }
            }
            return null;
        }

        function LoadCached() {
            if (localStorage.getItem("cached") != null) {
                redemptions = [];
                var b = (localStorage.getItem("cached")).split("~=~");
                b.forEach(ele => {
                    let a = JSON.parse(ele);
                    let date = new Date(a.redeemed_at);
                    if ((new Date().getTime() - date.getTime()) < 86400000) {
                        redemptions.push(a);
                    }
                });
                SaveCached();
            }
        }
        function SaveCached() {
            var array = [];
            redemptions.forEach(ele => {
                array.push(JSON.stringify(ele));
            });
            localStorage.setItem("cached", array.join("~=~"));
        }

        function AddRedemption(data) {
            if (!data.reviewed_at) {
                if (data.status != "unfulfilled") {
                    data.reviewed_at = new Date().toString();
                }
            }
            redemptions.unshift(data);
            SaveCached();
        }

        function UpdateRedemption(data) {
            if (!data.reviewed_at) {
                if (data.status != "unfulfilled") {
                    data.reviewed_at = new Date().toString();
                }
            }
            var A = -1;
            for (var i = 0; i < redemptions.length; i++) {
                if (redemptions[i].id == data.id) {
                    A = i;
                    break;
                }
            }
            if (A != -1) {
                redemptions[A] = data;
                SaveCached();
            }
        }

        let IntervalID = 0;

        function PingFrame() {
            b("YTChatDocument").contentWindow.postMessage("Wait_Check", "*");
        }

        function CheckPoll() {
            if (PE_Q == "Vote..." && PE_O[0] == "Yes" && PE_O[1] == "No") {
                b("yes_or_no_confirmation").showModal();
            }
            else {
                SubmitPoll();
            }
        }

        function SubmitPoll() {
            let url = new URL('https://api.twitch.tv/helix/polls');
            let Options = [];
            for (var i = 0; i < PE_O.length; i++) {
                if (PE_O[i].length > 0) {
                    Options.push({ "title": PE_O[i].substring(0, 25) });
                }
            }
            b("YTChatDocument").contentWindow.postMessage("Post_Poll", "*");
            b("CreatePollEditor").style = "display: none;";
            if (isNaN(Number.parseInt(b("Editor_PollDuration").value))) b("Editor_PollDuration").value = "60";
            fetch(
                url,
                {
                    "method": "POST",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        "Content-Type": "application/json"
                    },
                    "body": JSON.stringify({
                        "broadcaster_id": user_id,
                        "title": PE_Q.substring(0, 60),
                        "choices": Options,
                        "duration": Number.parseInt(b("Editor_PollDuration").value)
                    })
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.data) {
                        log('Got Created Poll');
                        ConnectedPollID = resp.data[0].id;
                        console.log(resp.data);
                    } else {
                        console.error('Failed to create poll', resp);
                    }
                })
                .catch(err => {
                    console.log(err);
                    log(`Error with Polls Call Call: ${err.message ? err.message : ''}`);
                });
            SetPleaseWait("Waiting for YouTube & Twitch");
            var CheckForPolls = setInterval(() => {
                if (ConnectedPollID == "NONE" && ConnectedYTPoll == "CURRENTLY_ACTIVE") {
                    SetPleaseWait("Waiting for Twitch");
                }
                if (ConnectedPollID != "NONE" && ConnectedYTPoll == "NONE") {
                    SetPleaseWait("Waiting for YouTube");
                }
                if (ConnectedPollID != "NONE" && ConnectedYTPoll == "CURRENTLY_ACTIVE") {
                    clearInterval(CheckForPolls);
                    b("PleaseWait").style = "display: none;";
                    b("CurrentPoll").style = "";
                    window.scrollTo(0, document.body.scrollHeight);
                    IntervalIDForPoll = setInterval(UpdatePollResponses, 150);
                    // PollStarttime = new Date();
                    // PollEndtime = new Date();
                    // PollEndtime.setSeconds(PollEndtime.getSeconds() + Number.parseInt(b("Editor_PollDuration").value) - 1);
                }
            }, 250);
        }

        var PollEndtime;
        var PollStarttime;
        var IntervalIDForPoll = 0;

        function LoadURL() {
            let URL = b("YouTubeURL").value;
            localStorage.setItem("saved_url", URL);
            var regExp = /.*(?:youtu.be\/|v\/|u\/\w\/|live\/|watch\?v=)([^#\&\?]*).*/;
            try {
                b("YTChatDocument").src = "https://youtube.com/live_chat?v=" + (URL.match(regExp)[1] ?? "none") + "&embed_domain=" + location.hostname;
                let OldText = b("YouTubeConnection").querySelector("span").innerHTML;
                if (!OldText.includes("invalid") && !OldText.includes("loaded")) {
                    if (IntervalID == 0) {
                        IntervalID = setInterval(PingFrame, 1000);
                    }
                    b("YouTubeConnection").querySelector("span").innerHTML = "YouTube Chat successfully loaded!";
                    b("YouTubeConnection").querySelector("span").style.color = "green";
                    setTimeout(() => {
                        b("YouTubeConnection").querySelector("span").innerHTML = OldText;
                        b("YouTubeConnection").querySelector("span").style.color = "";
                    }, 1000)
                }
            } catch (error) {
                let OldText = b("YouTubeConnection").querySelector("span").innerText;
                if (!OldText.includes("invalid") && !OldText.includes("loaded")) {
                    b("YouTubeConnection").querySelector("span").innerText = "Invalid YouTube URL!";
                    b("YouTubeConnection").querySelector("span").style.color = "red";
                    setTimeout(() => {
                        b("YouTubeConnection").querySelector("span").innerText = OldText;
                        b("YouTubeConnection").querySelector("span").style.color = "";
                    }, 1000)
                }
            }
        }

        function UpdatePollResponses() {
            b("PollOption3").style = PE_O[2].length > 0 ? "" : "display: none;";
            b("PPollOption3").parentElement.style = PE_O[2].length > 0 ? "" : "display: none;";
            b("PollOption4").style = PE_O[3].length > 0 ? "" : "display: none;";
            b("PPollOption4").parentElement.style = PE_O[3].length > 0 ? "" : "display: none;";
            // Timer
            var Now = new Date().getTime();
            var distance = PollEndtime.getTime() - Now;
            if (distance >= 0) {
                b("PPollDuration").style.width = ((1 - ((Now - PollStarttime.getTime()) / (PollEndtime.getTime() - PollStarttime.getTime()))) * 100) + "%";
                var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                var seconds = Math.floor((distance % (1000 * 60)) / 1000);
                b("PollDuration").innerText = ('0' + minutes).substring((minutes).toString().length - 1) + ":" + ('0' + seconds).substring((seconds).toString().length - 1);
            }

            if ((typeof TwitchPoll === 'object' && TwitchPoll != null) && (typeof YouTubePoll === 'object' && YouTubePoll != null)) {
                var CombinedVotes = Array((PE_O[2].length > 0 && PE_O[3].length > 0) ? 4 : ((PE_O[2].length > 0 || PE_O[3].length > 0) ? 3 : 2));
                var TwitchTotalVotes = 0;
                const YouTubeTotalVotes = YouTubePoll["Total"];
                for (let i = 0; i < TwitchPoll["votes"].length; i++) {
                    TwitchTotalVotes += TwitchPoll["votes"][i];
                    CombinedVotes[i] = TwitchPoll["votes"][i];
                }
                for (let i = 0; i < YouTubePoll["votes"].length; i++) {
                    CombinedVotes[i] += YouTubePoll["votes"][i];
                }
                const CombinedTotal = TwitchTotalVotes + YouTubeTotalVotes;
                getElementClass("PollQ").innerText = PE_Q + " (" + CombinedTotal + " Votes)";
                for (let i = 0; i < CombinedVotes.length; i++) {
                    b("PPollOption" + (i + 1)).style.width = `${Math.round(CombinedVotes[i] / ((CombinedTotal == 0) ? 1 : CombinedTotal) * 100)}%`;
                    b("PollOption" + (i + 1)).innerText = `${PE_O[i]} / ${Math.round(CombinedVotes[i] / ((CombinedTotal == 0) ? 1 : CombinedTotal) * 100)}% (${CombinedVotes[i]})`;
                }
            }
        }

        function EndPollEarly(AllowYouTubeEvents = false) {
            let url = new URL('https://api.twitch.tv/helix/polls');
            let Options = [];
            for (var i = 0; i < PE_O.length; i++) {
                if (PE_O[i].length > 0) {
                    Options.push({ "title": PE_O[i] });
                }
            }

            if (ConnectedYTPoll != "NONE") {
                if (AllowYouTubeEvents) {
                    b("YTChatDocument").contentWindow.postMessage("Stop_Poll", "*");
                }
                else {
                    b("YTChatDocument").contentWindow.postMessage("Stop_PollNoClear", "*"); ConnectedYTPoll = "ENDING_POLL_EARLY";
                }
            }
            if (ConnectedPollID != "NONE") {
                fetch(
                    url,
                    {
                        "method": "PATCH",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            "Content-Type": "application/json"
                        },
                        "body": JSON.stringify({
                            "broadcaster_id": user_id,
                            "id": ConnectedPollID,
                            "status": "TERMINATED"
                        })
                    }
                )
                    .then(resp => resp.json())
                    .then(resp => {
                        if (!resp.data) {
                            return Promise.reject('Failed to end poll');
                        }
                    })
                    .catch(err => {
                        console.log(err);
                        log(`Error with Polls Call Call: ${err.message ? err.message : ''}`);
                    });
            }
            b("CurrentPoll").style = "display: none;";
            b("PollWarning").style = "display: none;";
            SetPleaseWait("Ending YouTube & Twitch polls");
            var CheckForPolls = setInterval(() => {
                if (ConnectedPollID == "NONE" && ConnectedYTPoll != "NONE") {
                    SetPleaseWait("Ending YouTube poll");
                }
                if (ConnectedPollID != "NONE" && ConnectedYTPoll == "NONE") {
                    SetPleaseWait("Ending Twitch poll");
                }
                if (ConnectedPollID == "NONE" && ConnectedYTPoll == "NONE") {
                    clearInterval(CheckForPolls);
                    b("PleaseWait").style = "display: none;";
                    b("CreatePollEditor").style = "";
                }
            }, 250);
        }

        const ListOfUnauthorizedUsers = ["\u0057\u0065\u0074\u0068\u0061\u006E"];

        function processToken(token) {
            access_token = token;
            window.addEventListener("message", (ev) => {
                if (ev.data.MessageType == "editor_detailschange") {
                    Editor_SetPollDetails(ev.data.PollQuestion, ev.data.PollOptions[0], ev.data.PollOptions[1], ev.data.PollOptions[2], ev.data.PollOptions[3]);
                }
                if (ev.data.MessageType == "Pong") {
                    clearInterval(IntervalID);
                    IntervalID = 0;
                }
                if (ev.data.MessageType == "OptionsAvailable") {
                    console.log("[YT Poll] No poll is currently active.")
                    ConnectedYTPoll = "NONE";
                    if (ConnectedPollID == "NONE" && b("CurrentPoll").style.display == "none" && b("PleaseWait").style.display == "none" && b("CreatePollEditor").style.display == "none") {
                        b("CreatePollEditor").style = "";
                    }
                }
                if (ev.data.MessageType == "ActivePollAlready") {
                    console.log("[YT Poll] Found a poll that's active.")
                    ConnectedYTPoll = "CURRENTLY_ACTIVE";
                }
                if (ev.data.MessageType == "PollUpdateVotes") {
                    SetYouTubePoll(ev.data.PollOptions, ev.data.TotalVotes);
                }
            });
            fetch(
                'https://api.twitch.tv/helix/users',
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.error != undefined) {
                        return Promise.reject(resp.error + ": " + resp.message);
                    }
                    if (resp.data[0] != null && ListOfUnauthorizedUsers.includes(resp.data[0].login)) {
                        b("YTChatDocument").remove();
                        b("TwitchChatDummyDoc").remove();
                        b("YUHandler").remove();
                        b('PleaseWait').style = "color: red;";
                        b('PleaseWait').innerText = "You must request access to use this tool. Please get in touch with the website owner.";
                        b("YouTubeConnection").querySelector("span").innerText = "Type your YouTube Stream URL in order to connect with YouTube.";
                        return;
                    }
                    if (window.location.hash.length > 0) window.location.hash = "#authorized";
                    localStorage.setItem("saved_access_token", token);
                    document.getElementById("AuthRequired").remove();
                    b("TwitchChatDummyDoc").src = "https://www.twitch.tv/embed/" + resp.data[0].login + "/chat?parent=seenwonderalex.github.io"
                    SetPleaseWait("Waiting for YouTube & Twitch");
                    let Val = 0;
                    var CheckForPolls = setInterval(() => {
                        if (b("TwitchChatDummyDoc").src == "about:blank" || b("YTChatDocument").src == "about:blank") {
                            SetPleaseWait("Waiting for " + ((b("TwitchChatDummyDoc").src == "about:blank" && b("YTChatDocument").src == "about:blank") ? "YouTube & Twitch" : ((b("YTChatDocument").src == "about:blank") ? "YouTube" : "Twitch")));
                            return;
                        }
                        if (ConnectedPollID.length <= 0 && ConnectedYTPoll.length <= 0) {
                            SetPleaseWait("Checking active polls for YouTube & Twitch");
                        }
                        if (ConnectedPollID.length > 0 && ConnectedYTPoll.length <= 0) {
                            SetPleaseWait(Val >= 40 ? "On youtube.com, check if you're logged in to your streaming account. As well as having the Compatibility Extension" : "Checking active polls for YouTube");
                            Val++;
                        }
                        if (ConnectedPollID.length <= 0 && ConnectedYTPoll.length > 0) {
                            SetPleaseWait("Checking active polls for Twitch");
                        }
                        if (ConnectedPollID.length > 0 && ConnectedYTPoll.length > 0) {
                            clearInterval(CheckForPolls);
                            b("PleaseWait").style = "display: none;";
                            if (ConnectedPollID == "NONE" && ConnectedYTPoll == "NONE") {
                                b("CreatePollEditor").style = "";
                            }
                            if (ConnectedPollID != "NONE" && ConnectedYTPoll == "NONE") {
                                b("PollWarning").style = "";
                                getElementClass("PollWarningText").innerText = "You currently have an active poll for Twitch. Do you want to continue creating a multistreaming Poll & end Twitch poll?";
                            }
                            if (ConnectedPollID == "NONE" && ConnectedYTPoll == "CURRENTLY_ACTIVE") {
                                b("PollWarning").style = "";
                                getElementClass("PollWarningText").innerText = "You currently have an active poll for YouTube. Do you want to continue creating a multistreaming Poll & end YouTube poll?";
                            }
                            if (ConnectedPollID != "NONE" && ConnectedYTPoll == "CURRENTLY_ACTIVE") {
                                b("PollWarning").style = "";
                                getElementClass("PollWarningText").innerText = "You currently have an active poll for both platforms. Do you want to continue creating a multistreaming Poll & end both polls?";
                            }
                        }
                    }, 250)
                    socket_space = new initSocket(true);
                    // and build schnanaigans
                    socket_space.on('connected', (id) => {
                        log(`Connected to WebSocket with ${id}`);
                        session_id = id;
                        user_id = resp.data[0].id;
                        checkPolls(resp.data[0].id);
                        requestHooks(resp.data[0].id);
                    });

                    socket_space.on('session_keepalive', () => {
                        console.log("New Keepalive: " + new Date());
                    });

                    socket_space.on('channel.poll.begin', (msg) => {
                        let { metadata, payload } = msg;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Start Poll event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        PastMessageIDs.push(metadata.message_id);
                        let { event } = payload;
                        ConnectedPollID = event.id;
                        PollStarttime = new Date(event.started_at);
                        PollEndtime = new Date(event.ends_at);
                        SetTwitchPoll(event, true);
                        b('PollResultsDiv').open = false;
                    });
                    socket_space.on('channel.poll.progress', (msg) => {
                        let { metadata, payload } = msg;
                        let { event } = payload;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Progress Poll event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        PastMessageIDs.push(metadata.message_id);
                        ConnectedPollID = event.id;
                        SetTwitchPoll(event);
                    });
                    socket_space.on('channel.poll.end', (msg) => {
                        let { metadata, payload } = msg;
                        let { event } = payload;
                        let { id } = event;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored End Poll event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        PastMessageIDs.push(metadata.message_id);
                        if (id != ConnectedPollID) {
                            console.error("Ignored End Poll event since the current Poll ID does not match with the event (this is due to Twitch probably re-sending events)")
                            return;
                        }
                        SetTwitchPoll(event);
                        b('PollResultsDiv').style = "";
                        b("CurrentPoll").style = "display: none;";
                        clearInterval(IntervalIDForPoll);
                        CalculateResults();
                        ConnectedPollID = "NONE";
                        if (ConnectedYTPoll == "CURRENTLY_ACTIVE") {
                            b("YTChatDocument").contentWindow.postMessage("Stop_Poll", "*");
                        }
                    });
                    socket_space.on('channel.channel_points_custom_reward_redemption.add', (msg) => {
                        let { metadata, payload } = msg;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Add Redemption event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        if (GetRedemptionData(payload.event.id) != null) {
                            console.error("Ignored Add Redemption event due to duplicate redemption IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        AddRedemption(payload.event);
                    });
                    socket_space.on('channel.channel_points_custom_reward_redemption.update', (msg) => {
                        let { metadata, payload } = msg;
                        let { event } = payload;
                        if (PastMessageIDs.includes(metadata.message_id)) {
                            console.error("Ignored Update Status event due to duplicate message IDs (this is due to Twitch probably re-sending events)");
                            return;
                        }
                        if (GetRedemptionData(payload.event.id) == null) {
                            AddRedemption(payload.event);
                            return;
                        }
                        UpdateRedemption(payload.event);
                    });
                })
                .catch(err => {
                    console.error(err);
                    log('Error with Users Call');
                    localStorage.removeItem("saved_access_token");
                    document.getElementById("AuthRequired").style = '';
                    b("AuthRequired").className = "Oops";
                    b("AuthRequired").getElementsByTagName('img')[0].src = './cdn/Weirdge-perry8782-7tv.gif';
                    b("AuthRequired").getElementsByTagName('span')[0].innerText = "We could not access your Twitch account anymore. " + err;
                    b("authorize").innerText = "Reauthorize Twitch";
                });
        }

        let PastMessageIDs = [];
        var SPAM_AMOUNT = 0;
        var LAST_TIME = new Date();

        function CalculateResults() {
            b("Res_PollOption3").style = PE_O[2].length > 0 ? "" : "display: none;";
            b("Res_PollOption4").style = PE_O[3].length > 0 ? "" : "display: none;";
            if ((typeof TwitchPoll === 'object' && TwitchPoll != null) && (typeof YouTubePoll === 'object' && YouTubePoll != null)) {
                b('PollResultsDiv').open = true;
                b("RPOpt1_TTV").parentElement.style = "display: flex;";
                b("RPOpt2_TTV").parentElement.style = "display: flex;";
                b("RPOpt3_TTV").parentElement.style = PE_O[2].length > 0 ? "display: flex;" : "display: flex; display: none;";
                b("RPOpt4_TTV").parentElement.style = PE_O[3].length > 0 ? "display: flex;" : "display: flex; display: none;";

                var CombinedVotes = Array((PE_O[2].length > 0 && PE_O[3].length > 0) ? 4 : ((PE_O[2].length > 0 || PE_O[3].length > 0) ? 3 : 2));
                var TwitchTotalVotes = 0;
                const YouTubeTotalVotes = YouTubePoll["Total"];
                for (let i = 0; i < TwitchPoll["votes"].length; i++) {
                    TwitchTotalVotes += TwitchPoll["votes"][i];
                    CombinedVotes[i] = TwitchPoll["votes"][i];
                }
                for (let i = 0; i < YouTubePoll["votes"].length; i++) {
                    CombinedVotes[i] += YouTubePoll["votes"][i];
                }
                const CombinedTotal = TwitchTotalVotes + YouTubeTotalVotes;
                b("Res_PollQuestion").innerText = PE_Q
                b("Res_PollQuestionInfo").innerText = " (" + CombinedTotal + " Votes) T: " + TwitchTotalVotes + " Y: " + YouTubeTotalVotes;
                for (let i = 0; i < CombinedVotes.length; i++) {
                    b("Res_PollOption" + (i + 1)).innerText = `${PE_O[i]} / ${Math.round(CombinedVotes[i] / ((CombinedTotal == 0) ? 1 : CombinedTotal) * 100)}% (${CombinedVotes[i]}) T: ${TwitchPoll["votes"][i]} Y: ${YouTubePoll["votes"][i]}`;
                    if (TwitchPoll["votes"][i] == 0 && YouTubePoll["votes"][i] > 0) {
                        b('RPOpt' + (i + 1) + "_TTV").style.width = "0%";
                        b('RPOpt' + (i + 1) + "_YT").style.borderTopLeftRadius = "25px";
                        b('RPOpt' + (i + 1) + "_YT").style.borderBottomLeftRadius = "25px";
                        b('RPOpt' + (i + 1) + "_YT").style.width = Math.round((YouTubePoll["votes"][i] / CombinedTotal) * 100) + "%";
                    }
                    else if (TwitchPoll["votes"][i] > 0 && YouTubePoll["votes"][i] == 0) {
                        b('RPOpt' + (i + 1) + "_YT").style.width = "0%";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderTopRightRadius = "25px";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderBottomRightRadius = "25px";
                        b('RPOpt' + (i + 1) + "_TTV").style.width = Math.round((TwitchPoll["votes"][i] / CombinedTotal) * 100) + "%";
                    }
                    else {
                        b('RPOpt' + (i + 1) + "_YT").style.borderTopLeftRadius = "0";
                        b('RPOpt' + (i + 1) + "_YT").style.borderBottomLeftRadius = "0";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderTopRightRadius = "0";
                        b('RPOpt' + (i + 1) + "_TTV").style.borderBottomRightRadius = "0";
                        b('RPOpt' + (i + 1) + "_TTV").style.width = Math.round((TwitchPoll["votes"][i] / CombinedTotal) * 100) + "%";
                        b('RPOpt' + (i + 1) + "_YT").style.width = Math.round((YouTubePoll["votes"][i] / CombinedTotal) * 100) + "%";
                    }
                }
                window.scrollTo(0, document.body.scrollHeight);
            }
        }

        function log(Message) {
            console.log(Message);
        }

        function YoutubeLinkHandler() {
            // Google's OAuth 2.0 endpoint for requesting an access token
            var oauth2Endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';

            // Create <form> element to submit parameters to OAuth 2.0 endpoint.
            var form = document.createElement('form');
            form.setAttribute('method', 'GET'); // Send as a GET request.
            form.setAttribute('action', oauth2Endpoint);

            // Parameters to pass to OAuth 2.0 endpoint.
            var params = {
                'client_id': '597860444523-l87m271jorgmc0a9ea2vnn4ohqkmjphi.apps.googleusercontent.com',
                'redirect_uri': (() => { let str = window.location.href; if (str.includes('?')) { str = str.split('?')[0]; } if (str.includes('#')) { str = str.split('#')[0]; } return str; })(),
                'response_type': 'token',
                'scope': 'https://www.googleapis.com/auth/youtube.readonly',
                'include_granted_scopes': 'true',
                'state': 'yt35hv1'
            };

            // Add form parameters as hidden input values.
            for (var p in params) {
                var input = document.createElement('input');
                input.setAttribute('type', 'hidden');
                input.setAttribute('name', p);
                input.setAttribute('value', params[p]);
                form.appendChild(input);
            }

            // Add form to page and submit it to open the OAuth 2.0 endpoint.
            document.body.appendChild(form);
            form.submit();
        }

        function requestHooks(user_id) {
            let topics = {
                'channel.poll.begin': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.poll.progress': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.poll.end': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.channel_points_custom_reward_redemption.add': { version: '1', condition: { broadcaster_user_id: user_id } },
                'channel.channel_points_custom_reward_redemption.update': { version: '1', condition: { broadcaster_user_id: user_id } }
            }
            // if (ENABLE_SPAM_PROTECTION) {
            //     topics['channel.ban'] = { version: '1', condition: { broadcaster_user_id: user_id } };
            //     topics['channel.chat.message'] = { version: '1', condition: { broadcaster_user_id: user_id, user_id: user_id } };
            // }

            log(`Spawn Topics for ${user_id}`);

            for (let type in topics) {
                log(`Attempt create ${type} - ${user_id}`);
                let { version, condition } = topics[type];

                fetch(
                    'https://api.twitch.tv/helix/eventsub/subscriptions',
                    {
                        "method": "POST",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            'Content-Type': 'application/json'
                        },
                        "body": JSON.stringify({
                            type,
                            version,
                            condition,
                            transport: {
                                method: "websocket",
                                session_id
                            }
                        })
                    }
                )
                    .then(resp => resp.json())
                    .then(resp => {
                        if (resp.error) {
                            log(`Error with eventsub Call ${type} Call: ${resp.message ? resp.message : ''}`);
                        } else {
                            log(`Created ${type}`);
                            if (type == "channel.channel_points_custom_reward_redemption.add") {
                                LoadCached();
                            }
                        }
                    })
                    .catch(err => {
                        console.log(err);
                        log(`Error with eventsub Call ${type} Call: ${err.message ? err.message : ''}`);
                    });
            }
        }





        function checkPolls(broadcaster_id) {
            console.log('Get Existing Poll');

            let url = new URL('https://api.twitch.tv/helix/polls');
            let params = {
                broadcaster_id
            };
            url.search = new URLSearchParams(params).toString();

            fetch(
                url,
                {
                    "method": "GET",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Accept': 'application/json'
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.data && resp.data.length > 0) {
                        log('Got Poll');
                        if (resp.data[0].status == "ACTIVE") {
                            ConnectedPollID = resp.data[0].id;
                        }
                        else {
                            ConnectedPollID = "NONE";
                        }
                    } else {
                        log('No Polls Available');
                        ConnectedPollID = "NONE";
                    }
                })
                .catch(err => {
                    console.log(err);
                    log(`Error with Polls Call Call: ${err.message ? err.message : ''}`);
                });
        }

        let TwitchPoll;

        function SetTwitchPoll(JSON, MissingVotes = false) {
            try {
                let TP_Options = [];
                for (let index = 0; index < PE_O.length; index++) {
                    if (PE_O[index].length > 0) {
                        TP_Options.push(MissingVotes ? 0 : JSON.choices[index].votes);
                    }
                }
                TwitchPoll = { "votes": TP_Options }
            } catch (error) {
                console.log(error);
            }

        }

        let YouTubePoll;

        function SetYouTubePoll(Votes, Total) {
            YouTubePoll = { "votes": Votes, "Total": Total };
        }

        var PleaseWaitInterval = -1;

        var PWText = "";
        var PleaseWaitText = document.getElementsByClassName('PleaseWait')[0];

        function SetPleaseWait(TextToInput) {
            b('PleaseWait').style = "";
            if (PWText == TextToInput) return;
            PWText = TextToInput;
            PleaseWaitText.innerText = TextToInput + EllipsisText[Ellipsis];
            if (PleaseWaitInterval == -1) {
                PleaseWaitInterval = setInterval(() => {
                    if (Ellipsis < 3) {
                        Ellipsis++;
                    }
                    else {
                        Ellipsis = 0;
                    }
                    if (b('PleaseWait').style.display == "none") { clearInterval(PleaseWaitInterval); PleaseWaitInterval = -1; }
                    if (document.hidden) return;
                    PleaseWaitText.innerText = PWText + EllipsisText[Ellipsis];
                }, 200)
            }
        }

        var PE_Q = '';
        var PE_O = ['', '', '', '']

        function Editor_SetPollDetails(Question = "", Option1 = "", Option2 = "", Option3 = "", Option4 = "") {
            PE_Q = Question.length > 0 ? Question : "Vote...";
            PE_O[0] = Option1.length > 0 ? Option1 : "Yes";
            PE_O[1] = Option2.length > 0 ? Option2 : "No";
            PE_O[2] = Option3;
            PE_O[3] = Option4;
        }

    </script>
</body>

</html>