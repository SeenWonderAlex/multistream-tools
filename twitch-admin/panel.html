<html>

<title>Multistream Tools - Twitch Mod Panel</title>

<head>
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../style.css" />
    <style>
        .Panel {
            width: 300px;
            height: 450px;
            border: 2px solid white;
            float: left;
            overflow: auto;
        }

        #loading {
            height: 200px;
            overflow: scroll;
        }

        #loading p {
            margin: 2px;
        }

        #left,
        #right {
            box-sizing: border-box;
            width: 49vw;
            display: inline-block;
            vertical-align: top;
        }

        form {
            width: 50%;
        }

        form>fieldset>div {
            width: 100%;
        }

        form>fieldset>div>div {
            display: inline-block;
            width: 49%;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
        }

        input[type="button"],
        input[type="submit"] {
            width: 30%;
            background: green;
            cursor: pointer;
        }

        input[type="button"]:hover,
        input[type="submit"]:hover {
            background: red;
        }

        tr td:nth-child(6),
        tr td:nth-child(7),
        .delete_reward {
            cursor: pointer;
        }

        .removeButton {
            width: 30px;
            height: 25px;
            float: right;
            position: relative;
            top: 6px;
            background: #c60000;
        }

        .removeButton:hover {
            background: #b40000;
        }

        .addButton {
            position: absolute;
            width: 30px;
            float: right;
            height: 22px;
            width: 25px;
        }
    </style>
</head>

<body>
    <details open>
        <summary>Access</summary>
        <input id="TwitchUser" class="YU1" type="text" style="width: 250px" placeholder="Twitch User">
        <button id="TwitchFindButton" onclick="FindUser();"
            style="width: 60px; height: 27px; font-size: 16px;">Find</button>
        <span style="display: none; color:red;" id="Fail">Hello!</span>
    </details>
    <div>
        <div>
            <div class="Panel" id="Moderators">
                <span>Moderators</span>
                <br>
            </div>
            <div class="Panel" id="VIPs">
                <span>VIPs</span>
                <br>
            </div>
            <iframe class="Panel" id="Panel_Rewards" src="about:blank" height="450"></iframe>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Editable Here</th>
                    <!-- <th>Reward ID</th> -->
                    <th>Image</th>
                    <th>Reward Title</th>
                    <th>Cost</th>
                    <th>Visible</th>
                    <th>Paused</th>
                    <th>Skip Queue</th>
                    <th>Prompt</th>
                    <th>User Input Req.</th>
                    <th>X</th>
                </tr>
            </thead>
            <tbody id="output"></tbody>
        </table>

        <div style="width: 50%">
            <form id="announcement_form" action="" method="post">
                <fieldset>
                    <div>
                        <label for="announcement_title">Announcement Message</label>
                        <input type="text" name="announcement_title" id="announcement_title" required>
                    </div>
                    <div>
                        <label for="announcement_dropdown">Announcement Color</label>
                        <select type="" name="announcement_dropdown" id="announcement_dropdown" required>
                            <option value="blue">Blue</option>
                            <option value="primary">Channel's Color</option>
                            <option value="green">Green</option>
                            <option value="orange">Orange</option>
                            <option value="purple">Purple</option>
                        </select>
                    </div>
                    <div>
                        <input type="submit" value="Send" />
                    </div>
                </fieldset>
            </form>
        </div>
        <form id="reward_create_form" action="" method="post">
            <fieldset>
                <div>
                    <label for="reward_title">Reward Title</label>
                    <input type="text" name="reward_title" id="reward_title" />
                </div>
                <div>
                    <div>
                        <label for="reward_cost">Reward Cost</label>
                        <input type="number" name="reward_cost" id="reward_cost" min="1" step="1" value="50" />
                    </div>
                    <div>
                        <label for="reward_prompt">Reward Prompt</label>
                        <input type="text" name="reward_prompt" id="reward_prompt" />
                    </div>
                </div>
                <div>
                    <label for="reward_background_color">Background Color</label>
                    <input type="color" name="reward_background_color" id="reward_background_color" />
                </div>
                <div>
                    <div>
                        <label for="reward_is_enabled">Enabled</label>
                        <input type="checkbox" name="reward_is_enabled" id="reward_is_enabled" />
                    </div>
                    <div>
                        <label for="reward_is_user_input_required">User Input Required</label>
                        <input type="checkbox" name="reward_is_user_input_required"
                            id="reward_is_user_input_required" />
                    </div>
                </div>
                <div>
                    <div>
                        <label for="reward_should_redemptions_skip_request_queue">Skip Queue</label>
                        <input type="checkbox" name="reward_should_redemptions_skip_request_queue"
                            id="reward_should_redemptions_skip_request_queue" />
                    </div>
                </div>
                <div>
                    <div>
                        <label for="is_max_per_stream_enabled">Max Per Stream</label>
                        <input type="checkbox" name="is_max_per_stream_enabled" id="is_max_per_stream_enabled" />
                        <input type="number" name="max_per_stream" id="max_per_stream" min="1" max="100" step="1" />
                    </div>
                    <div>
                        <label for="is_max_per_user_per_stream_enabled">Max Per User Per Stream</label>
                        <input type="checkbox" name="is_max_per_user_per_stream_enabled"
                            id="is_max_per_user_per_stream_enabled" />
                        <input type="number" name="max_per_user_per_stream" id="max_per_user_per_stream" min="1"
                            max="100" step="1" />
                    </div>
                </div>
                <div>
                    <div>
                        <label for="is_global_cooldown_enabled">Cool Down between (seconds)</label>
                        <input type="checkbox" name="is_global_cooldown_enabled" id="is_global_cooldown_enabled" />
                        <input type="number" name="global_cooldown_seconds" id="global_cooldown_seconds" min="30"
                            max="86400" step="30" />
                    </div>
                </div>

                <div>
                    <input type="submit" value="Create" />
                </div>
            </fieldset>
        </form>
    </div>
    <dialog id="dialogpunish">
        <form method="dialog" onsubmit="Punish()">
            <span style="font-size: 24px;">Punish User</span>
            <input id="punish_name" class="YU1" placeholder="Twitch User" required>
            <input id="punish_timeoutamount" class="YU1" min="0" max="1209600"
                placeholder="Timeout Duration | 0=Ban 1-1209600=Timeout" type="number"
                onkeydown="if(event.key==='.'){event.preventDefault();}"
                oninput="event.target.value = event.target.value.replace(/[^0-9]*/g,'');" required>
            <input id="punish_reason" class="YU1" placeholder="Reason" style="display: none;" maxlength="500">
            <input id="punish_remod" name="remod" type="checkbox" style="width: 15px" checked>
            <label for="remod">Re-mod Twitch User after Timeout</label>
            <br>
            <button id="cancelBtn" class="SubmitPoll" style="width:90px;" type="button"
                onclick="b('dialogpunish').close()">Cancel</button>
            <button id="confirmBtn" style="width:120px;" oncontextmenu="ToggleTimeoutState(event)">Punish</button>
        </form>
    </dialog>
    <script type="text/javascript" src="../eventsub.js"></script>
    <script type="text/javascript" src="channel-points-example.js"></script>
    <script type="text/javascript" src="encryption.js"></script>
    <script type="text/javascript">
        var client_id = 'siayiyd16jh90e3j473ckuu2seoq0p';
        var redirect = (() => { let str = window.location.href; if (str.includes('?')) { str = str.split('?')[0]; } if (str.includes('#')) { str = str.split('#')[0]; } return str; })();
        var access_token = '';
        var socket_space = '';
        var session_id = '';
        var user_id = '';

        let USER_FETCHED = {};

        let ACCESS_TOKEN = localStorage.getItem("db_access_token") ?? "";


        let CURRENT_CHANNEL = {};

        let SAVED_ACCESS_KEY = localStorage.getItem("saved_user_access") ?? "";

        let PUNISHDIALOG_STATE = 0;

        document.querySelector('div').style.display = "none";

        function b(Id) {
            return document.getElementById(Id);
        }

        if ((localStorage.getItem("saved_user") ?? "").length > 0) {
            b('TwitchUser').value = localStorage.getItem("saved_user");
            FindUser(true);
        }

        function FindUser(FindingFromScript = false) {
            b("TwitchFindButton").disabled = true;
            b("Fail").style.display = "none";
            localStorage.setItem("saved_user", b('TwitchUser').value);
            if (!FindingFromScript) {
                localStorage.removeItem('saved_user_access');
                SAVED_ACCESS_KEY = "";
            }
            GetUser(b('TwitchUser').value).then(async item => {
                b("TwitchFindButton").disabled = false;
                if (item == null) return Promise.reject("This user has not setup your access yet.");
                else {
                    b("TwitchFindButton").innerText = "Change";
                    b("TwitchFindButton").style.width = "76px";
                    if (SAVED_ACCESS_KEY.length <= 0) // No access key
                    {
                        processToken(item.access); // Get the already decrypted data then
                        return;
                    }
                    const DECRYPTED_STR = await decryptData(item.access, SAVED_ACCESS_KEY); // Decrypting FROM ONLY THE USER INPUT KEY. ON THE USER'S DEVICE.
                    if ((DECRYPTED_STR || "FAILED") == "FAILED") {
                        return Promise.reject("This seems to be the wrong access key.");
                    }
                    processToken(DECRYPTED_STR);
                }

            }).catch(err => {
                console.error(err);
                b("TwitchFindButton").disabled = false;
                if (err == "KEY_NEEDED") {
                    if ((key = prompt("What's the access key for " + b('TwitchUser').value + "?")) != null) {
                        SAVED_ACCESS_KEY = key;
                        FindUser(true);
                    }
                    else {
                        SAVED_ACCESS_KEY = "";
                        localStorage.removeItem('saved_user_access');
                    }
                    return;
                }
                if (err == "KEY_INVALID") {
                    if ((key = prompt("WRONG! GIVE " + b('TwitchUser').value.toUpperCase() + " THE RIGHT ACCESS KEY.", SAVED_ACCESS_KEY)) != null) {
                        SAVED_ACCESS_KEY = key;
                        FindUser(true);
                    }
                    else {
                        SAVED_ACCESS_KEY = "";
                        localStorage.removeItem('saved_user_access');
                    }
                    return;
                }
                b("Fail").innerText = err;
                b("Fail").style.display = "";
            });
        }

        async function Punish() {
            let username = b('punish_name').value;
            let duration = b('punish_timeoutamount').value;
            let checked = b('punish_remod').checked;
            let reason = b('punish_reason').value;

            let Fetched = await fetch(
                'https://api.twitch.tv/helix/users?login=' + username.toLowerCase(),
                {
                    "method": "GET",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Content-Type': 'application/json'
                    }
                }
            );
            if (Fetched.status == 401) {
                location.reload();
                return;
            }
            let FetchedUser = (await Fetched.json()).data[0];
            if (FetchedUser == undefined) {
                alert("This user doesn't exist.");
                return;
            }

            if (PUNISHDIALOG_STATE == 1) // Untimeout
            {
                if (checked && !RemodUser_IsOnTheList(FetchedUser.id)) {
                    ListOfTimedOutMods[FetchedUser.id] = setTimeout(() => { }, 10000);
                }
                return fetch(
                    'https://api.twitch.tv/helix/moderation/bans?moderator_id=' + CURRENT_CHANNEL.id + '&broadcaster_id=' + CURRENT_CHANNEL.id + "&user_id=" + FetchedUser.id,
                    {
                        "method": "DELETE",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            'Content-Type': 'application/json'
                        }
                    }
                )
                    .then(async resp => {
                        if (resp.status == 401) {
                            location.reload();
                            return;
                        }
                        if (!resp.ok) {
                            alert((await resp.json()).message);
                            return;
                        }
                        if (!checked) UpdateModerators();
                    });
            }
            if (PUNISHDIALOG_STATE == 2) // Warning
            {
                if (checked && !RemodUser_IsOnTheList(FetchedUser.id)) {
                    ListOfTimedOutMods[FetchedUser.id] = setTimeout(() => { }, 10000);
                }
                let data = { "data": { "user_id": FetchedUser.id, "reason": reason } };
                return fetch(
                    'https://api.twitch.tv/helix/moderation/warnings?moderator_id=' + CURRENT_CHANNEL.id + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                    {
                        "method": "POST",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            'Content-Type': 'application/json'
                        },
                        "body": JSON.stringify(data)
                    }
                )
                    .then(async resp => {
                        if (resp.status == 401) {
                            location.reload();
                            return;
                        }
                        if (!resp.ok) {
                            alert((await resp.json()).message);
                            return;
                        }
                    });
            }

            if (checked && duration > 0 && (duration * 1000) <= 2147483647) {
                AddModTimeout(FetchedUser.id, duration);
            }
            else {
                let data = { "data": { "user_id": FetchedUser.id } };
                if (duration > 0) data.data.duration = duration;
                return fetch(
                    'https://api.twitch.tv/helix/moderation/bans?moderator_id=' + CURRENT_CHANNEL.id + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                    {
                        "method": "POST",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            'Content-Type': 'application/json'
                        },
                        "body": JSON.stringify(data)
                    }
                )
                    .then(async resp => {
                        if (resp.status == 401) {
                            location.reload();
                            return;
                        }
                        if (!resp.ok) {
                            alert((await resp.json()).message);
                            return;
                        }
                        UpdateModerators();
                    });
            }
        }

        let ListOfTimedOutMods = {};

        function AddModTimeout(user, duration) {
            return fetch(
                'https://api.twitch.tv/helix/moderation/bans?moderator_id=' + CURRENT_CHANNEL.id + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                {
                    "method": "POST",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Content-Type': 'application/json'
                    },
                    "body": JSON.stringify({ "data": { "user_id": user, "duration": duration } })
                }
            )
                .then(async resp => {
                    if (resp.status == 401) {
                        location.reload();
                        return;
                    }
                    let json = (await resp.json());
                    if (!resp.ok) {
                        alert(json.message);
                        return;
                    }
                    UpdateModerators();
                    let timeoutData = json.data[0];
                    window.onbeforeunload = (event => {
                        // Recommended
                        event.preventDefault();

                        // Included for legacy support, e.g. Chrome/Edge < 119
                        event.returnValue = true;
                    });
                    ListOfTimedOutMods[timeoutData.user_id] = setTimeout(() => {
                        if (RemodUser_IsOnTheList(timeoutData.user_id)) {
                            RemodUser(timeoutData.user_id);
                        }
                    }, ((new Date(timeoutData.end_time).getTime() - new Date(timeoutData.created_at).getTime())));
                })
        }

        function RemodUser_IsOnTheList(user_id) {
            return ListOfTimedOutMods[user_id] != undefined;
        }

        function RemodUser(user_id, Retry = false) {
            console.log("Remodding timed out moderator");
            delete ListOfTimedOutMods[user_id];
            return fetch(
                'https://api.twitch.tv/helix/moderation/moderators?user_id=' + user_id + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                {
                    "method": "POST",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Content-Type': 'application/json'
                    }
                }
            )
                .then(async resp => {
                    if (resp.status == 401) {
                        location.reload();
                        return;
                    }
                    console.log("Remaining timed out mods: " + Object.keys(ListOfTimedOutMods).length);
                    if (Object.keys(ListOfTimedOutMods).length <= 0) {
                        window.onbeforeunload = null;
                    }
                    if (!resp.ok) {
                        let message = (await resp.json()).message;
                        if (message == "user is banned" && !Retry) {
                            setTimeout(() => RemodUser(user_id, true), 1000);
                        }
                        console.error(message);
                        return;
                    }
                    UpdateModerators();
                });
        }

        function ShowPunishDialog(userId = "") {
            b("punish_name").value = "";
            b("punish_timeoutamount").value = "";
            b("punish_remod").checked = false;
            if (userId.length > 0) {
                return fetch(
                    'https://api.twitch.tv/helix/users?id=' + userId,
                    {
                        "method": "GET",
                        "headers": {
                            "Client-ID": client_id,
                            "Authorization": "Bearer " + access_token,
                            'Content-Type': 'application/json'
                        }
                    }
                ).then(async Fetched => {
                    if (Fetched.status == 401) {
                        location.reload();
                        return false;
                    }
                    let FetchedUser = (await Fetched.json()).data[0];
                    b("punish_name").value = FetchedUser.login;
                    return fetch(
                        'https://api.twitch.tv/helix/moderation/moderators?user_id=' + userId + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                        {
                            "method": "GET",
                            "headers": {
                                "Client-ID": client_id,
                                "Authorization": "Bearer " + access_token,
                                'Content-Type': 'application/json'
                            }
                        }
                    ).then(res => res.json()).then(res => {
                        if (res.data) {
                            if (res.data[0] != undefined) {
                                b("punish_remod").checked = true;
                            }
                        }
                        b('dialogpunish').showModal();
                        b("punish_timeoutamount").focus();
                    });
                })
            }
            else {
                b('dialogpunish').showModal();
                return Promise.resolve(true);
            }
        }

        function ToggleTimeoutState(ev) {
            ev.preventDefault();
            PUNISHDIALOG_STATE++;
            if (PUNISHDIALOG_STATE > 2) PUNISHDIALOG_STATE = 0;
            UpdateDialogTexts();
        }

        function UpdateDialogTexts() {
            switch (PUNISHDIALOG_STATE) {
                case 1:
                    b('dialogpunish').querySelector("form > span").innerText = "Remove Punishment from User";
                    b('dialogpunish').querySelector("form > #punish_timeoutamount").style = "display: none;";
                    b('dialogpunish').querySelector("form > #punish_timeoutamount").required = false;
                    b('dialogpunish').querySelector("form > #punish_reason").style = "display: none;";
                    b('dialogpunish').querySelector("form > #punish_reason").required = false;
                    b('confirmBtn').innerText = "Remove";
                    break;
                case 2:
                    b('dialogpunish').querySelector("form > span").innerText = "Issue Warning to User";
                    b('dialogpunish').querySelector("form > #punish_timeoutamount").style = "display: none;";
                    b('dialogpunish').querySelector("form > #punish_timeoutamount").required = false;
                    b('dialogpunish').querySelector("form > #punish_reason").removeAttribute('style');
                    b('dialogpunish').querySelector("form > #punish_reason").required = true;
                    b('confirmBtn').innerText = "Warn";
                    break;
                default:
                    b('dialogpunish').querySelector("form > span").innerText = "Punish User";
                    b('dialogpunish').querySelector("form > #punish_timeoutamount").removeAttribute('style');
                    b('dialogpunish').querySelector("form > #punish_timeoutamount").required = true;
                    b('dialogpunish').querySelector("form > #punish_reason").style = "display: none;";
                    b('dialogpunish').querySelector("form > #punish_reason").required = false;
                    b('confirmBtn').innerText = "Punish";
                    break;
            }
        }

        function UpdateModerators() {
            while (b('Moderators').firstChild) {
                b('Moderators').removeChild(b('Moderators').lastChild);
            }
            let ele = document.createElement('span');
            ele.innerText = "Moderators";
            b('Moderators').append(ele);
            let add = document.createElement('button');
            add.className = "addButton";
            add.innerText = "+";
            add.onclick = (async ev => {
                let User = prompt("Enter the username to add as a moderator");
                if (User != null) {
                    let Fetched = await fetch(
                        'https://api.twitch.tv/helix/users?login=' + User.toLowerCase(),
                        {
                            "method": "GET",
                            "headers": {
                                "Client-ID": client_id,
                                "Authorization": "Bearer " + access_token,
                                'Content-Type': 'application/json'
                            }
                        }
                    );
                    if (Fetched.status == 401) {
                        location.reload();
                        return;
                    }
                    let FetchedUser = (await Fetched.json()).data[0];
                    if (FetchedUser == undefined) {
                        alert("This user doesn't exist.");
                        return;
                    }

                    return fetch(
                        'https://api.twitch.tv/helix/moderation/moderators?user_id=' + FetchedUser.id + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                        {
                            "method": "POST",
                            "headers": {
                                "Client-ID": client_id,
                                "Authorization": "Bearer " + access_token,
                                'Content-Type': 'application/json'
                            }
                        }
                    )
                        .then(async resp => {
                            if (resp.status == 401) {
                                location.reload();
                                return;
                            }
                            if (!resp.ok) {
                                alert((await resp.json()).message);
                                return;
                            }
                            UpdateModerators();
                        })
                }
            });
            b('Moderators').append(add);
            b('Moderators').append(document.createElement('br'));

            return fetch(
                'https://api.twitch.tv/helix/moderation/moderators?first=100&broadcaster_id=' + CURRENT_CHANNEL.id,
                {
                    "method": "GET",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Content-Type': 'application/json'
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (!resp.data) {
                        return Promise.reject('Failed to fetch mods');
                    }
                    let IDs = new URLSearchParams();
                    for (var i = 0; i < resp.data.length; i++) {
                        IDs.append('id', resp.data[i].user_id);
                    }
                    FetchAndAddUsers(b('Moderators'), IDs.toString()).then(res => {
                        for (let j = 3; j < b('Moderators').children.length; j++) {
                            const child = b('Moderators').children[j];
                            const Button = document.createElement('button');
                            Button.className = "removeButton";
                            Button.innerText = "X";
                            child.appendChild(Button);

                            Button.onclick = (event => {
                                child.querySelector("img").style.filter = "grayscale(1)"
                                Button.disabled = true;
                                return fetch(
                                    'https://api.twitch.tv/helix/moderation/moderators?user_id=' + child.getAttribute('data-id') + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                                    {
                                        "method": "DELETE",
                                        "headers": {
                                            "Client-ID": client_id,
                                            "Authorization": "Bearer " + access_token,
                                            'Content-Type': 'application/json'
                                        }
                                    }
                                )
                                    .then(resp => {
                                        if (resp.status == 401) {
                                            location.reload();
                                            return;
                                        }
                                        UpdateModerators();
                                    })
                            });
                            Button.oncontextmenu = (event => {
                                event.preventDefault();
                                Button.disabled = true;
                                return ShowPunishDialog(child.getAttribute('data-id'))
                                    .then(() => { Button.disabled = false; })
                            });
                        }
                    });
                })
                .catch(err => { console.error(err); });
        }

        function UpdateVIPs() {
            while (b('VIPs').firstChild) {
                b('VIPs').removeChild(b('VIPs').lastChild);
            }
            let ele = document.createElement('span');
            ele.innerText = "VIPs";
            b('VIPs').append(ele)
            let add = document.createElement('button');
            add.className = "addButton";
            add.innerText = "+";
            add.onclick = (async ev => {
                let User = prompt("Enter the username to add as a VIP");
                if (User != null) {
                    let Fetched = await fetch(
                        'https://api.twitch.tv/helix/users?login=' + User.toLowerCase(),
                        {
                            "method": "GET",
                            "headers": {
                                "Client-ID": client_id,
                                "Authorization": "Bearer " + access_token,
                                'Content-Type': 'application/json'
                            }
                        }
                    );
                    if (Fetched.status == 401) {
                        location.reload();
                        return;
                    }
                    let FetchedUser = (await Fetched.json()).data[0];
                    if (FetchedUser == undefined) {
                        alert("This user doesn't exist.");
                        return;
                    }

                    return fetch(
                        'https://api.twitch.tv/helix/channels/vips?user_id=' + FetchedUser.id + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                        {
                            "method": "POST",
                            "headers": {
                                "Client-ID": client_id,
                                "Authorization": "Bearer " + access_token,
                                'Content-Type': 'application/json'
                            }
                        }
                    )
                        .then(async resp => {
                            if (resp.status == 401) {
                                location.reload();
                                return;
                            }
                            if (!resp.ok) {
                                alert((await resp.json()).message);
                                return;
                            }
                            UpdateVIPs();
                        })
                }
            });
            b('VIPs').append(add);
            b('VIPs').append(document.createElement('br'));

            return fetch(
                'https://api.twitch.tv/helix/channels/vips?first=100&broadcaster_id=' + CURRENT_CHANNEL.id,
                {
                    "method": "GET",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Content-Type': 'application/json'
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (!resp.data) {
                        return Promise.reject('Failed to fetch vips');
                    }
                    let IDs = new URLSearchParams();
                    for (var i = 0; i < resp.data.length; i++) {
                        IDs.append('id', resp.data[i].user_id);
                    }
                    FetchAndAddUsers(b('VIPs'), IDs.toString()).then(res => {
                        for (let j = 3; j < b('VIPs').children.length; j++) {
                            const child = b('VIPs').childNodes[j];
                            const Button = document.createElement('button');
                            Button.className = "removeButton";
                            Button.innerText = "X";
                            child.appendChild(Button);

                            Button.onclick = (event => {
                                child.querySelector("img").style.filter = "grayscale(1)"
                                Button.disabled = true;
                                return fetch(
                                    'https://api.twitch.tv/helix/channels/vips?user_id=' + child.getAttribute('data-id') + '&broadcaster_id=' + CURRENT_CHANNEL.id,
                                    {
                                        "method": "DELETE",
                                        "headers": {
                                            "Client-ID": client_id,
                                            "Authorization": "Bearer " + access_token,
                                            'Content-Type': 'application/json'
                                        }
                                    }
                                )
                                    .then(resp => {
                                        if (resp.status == 401) {
                                            location.reload();
                                            return;
                                        }
                                        UpdateVIPs();
                                    })
                            });
                        }
                    });
                })
                .catch(err => { console.error(err); });
        }

        async function GetUser(user = "twitch") {
            let PARAMS = {
                "method": "POST",
                "headers": {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer daw9dj215435",
                    "Access-Control-Request-Headers": "*"
                }
            };
            if (SAVED_ACCESS_KEY.length > 0) {
                PARAMS.body = JSON.stringify({ access_key: await getSHA256Hash(SAVED_ACCESS_KEY) });
            }
            return fetch('https://seenwalex.wixsite.com/site/_functions/GetConsentedAccess?name=' + user.toLowerCase(), PARAMS).then(async result => {
                if (result.status == 401) {
                    localStorage.removeItem('saved_access_key');
                    return Promise.reject(await result.text());
                }
                return result.json();
            }).then(json => {
                localStorage.setItem('saved_user_access', SAVED_ACCESS_KEY);
                return json.document;
            })
        }

        function FetchAndAddUsers(container, users) {
            const paramUsers = new URLSearchParams(users);
            let ToDelete = [];
            for (const [key, value] of paramUsers.entries()) {
                if (key === "id") {
                    if (USER_FETCHED[value] != undefined) {
                        let DIV = document.createElement('div');
                        container.appendChild(DIV);

                        DIV.setAttribute('data-id', value);

                        let IMAGE = document.createElement('img');
                        IMAGE.className = "profile";
                        DIV.appendChild(IMAGE);
                        IMAGE.src = USER_FETCHED[value]["profile_image_url"];

                        let USERTEXT = document.createElement('span');
                        USERTEXT.className = "text";
                        USERTEXT.innerHTML = " " + USER_FETCHED[value].display_name;
                        DIV.appendChild(USERTEXT);
                        ToDelete.push({ "key": key, "value": value });
                    }
                }
            }
            for (const v of ToDelete) {
                paramUsers.delete(v.key, v.value);
            }
            if (paramUsers.size <= 0) {
                return Promise.resolve(true);
            }
            return fetch(
                'https://api.twitch.tv/helix/users?' + paramUsers.toString(),
                {
                    "method": "GET",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Content-Type': 'application/json'
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (!resp.data) {
                        return Promise.reject('Failed to fetch user');
                    }
                    for (var i = 0; i < resp.data.length; i++) {
                        USER_FETCHED[resp.data[i].id] = resp.data[i];
                        let DIV2 = document.createElement('div');
                        container.appendChild(DIV2);
                        DIV2.setAttribute('data-id', resp.data[i].id);

                        let IMAGE2 = document.createElement('img');
                        IMAGE2.className = "profile";
                        DIV2.appendChild(IMAGE2);
                        IMAGE2.src = resp.data[i]["profile_image_url"];

                        let USERTEXT2 = document.createElement('span');
                        USERTEXT2.className = "text";
                        USERTEXT2.innerHTML = " " + resp.data[i].display_name;
                        DIV2.appendChild(USERTEXT2);
                    }
                    return true;
                })
                .catch(err => {
                    console.log(err);
                    let DIV3 = document.createElement('div');
                    DIV3.style = "position: absolute;";
                    container.appendChild(DIV3);

                    let USERTEXT3 = document.createElement('span');
                    USERTEXT3.innerHTML = " List Failed to Load";
                    DIV3.appendChild(USERTEXT3);
                    log(`Error with Profile Fetching: ${err.message ? err.message : ''}`);
                    return false;
                });
        }

        function processToken(token) {
            access_token = token;
            b("Panel_Rewards").src = "about:blank;";
            fetch(
                'https://api.twitch.tv/helix/users',
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.error != undefined) {
                        return Promise.reject(resp.error + ": " + resp.message);
                    }
                    CURRENT_CHANNEL = resp.data[0];
                    UpdateModerators();
                    UpdateVIPs();
                    processToken_forRewards(token);
                    document.querySelector('div').style.display = "";
                    b("Panel_Rewards").src = "../ttv-redemptions.html?tp=true#access_token=" + token;
                    b('announcement_form').onsubmit = (ev => {
                        ev.preventDefault();
                        b('announcement_form').querySelector('div > input[type=submit]').disabled = true;
                        fetch(`https://api.twitch.tv/helix/chat/announcements?broadcaster_id=${CURRENT_CHANNEL.id}&moderator_id=${CURRENT_CHANNEL.id}`, {
                            "method": "POST", "headers": {
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer ' + access_token,
                                'Client-Id': client_id
                            }, "body": JSON.stringify({
                                "message": b('announcement_title').value,
                                "color": b('announcement_dropdown').value
                            })
                        }).then(res => {
                            if (res.status == 401) { location.reload(); return; }
                            if (!res.ok) {
                                alert("Failed to send message");
                            }
                            b('announcement_form').querySelector('input[type=submit]').disabled = false;
                        }).catch(err => { console.error(err); b('announcement_form').querySelector('input[type=submit]').disabled = false; })
                    });
                })
                .catch(err => {
                    console.error(err);
                    b("Fail").innerText = "This user removed their access.";
                    b("Fail").style.display = "";
                });
        }

    </script>
</body>

</html>